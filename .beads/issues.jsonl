{"id":"bd-14i","title":"Implement FastMCP theme system","description":"# Implement FastMCP Theme System\n\n## Purpose\nDefine a cohesive visual identity for FastMCP that creates a premium, professional appearance. The theme system provides consistent colors, styles, and visual language across all rich output. This is the \"brand\" of FastMCP's terminal experience.\n\n## Design Philosophy\n1. **Futuristic/Technical**: Cyan, purple, electric green evoke modern tech aesthetic\n2. **High Contrast**: Readable on both dark and light terminal backgrounds\n3. **Semantic Colors**: Success=green, Warning=amber, Error=red (universally understood)\n4. **Accessibility**: Colors chosen with sufficient contrast ratios\n5. **Consistency**: All FastMCP output uses these same colors\n\n## Color Palette\n\n### Primary Colors (Brand Identity)\n| Name | Hex | RGB | Purpose |\n|------|-----|-----|---------|\n| Primary | #00d4ff | (0, 212, 255) | Main brand color, headers, highlights |\n| Secondary | #a855f7 | (168, 85, 247) | Accent, keys, important items |\n| Accent | #22c55e | (34, 197, 94) | Success indicators, active elements |\n\n### Semantic Colors (Status/Feedback)\n| Name | Hex | RGB | Purpose |\n|------|-----|-----|---------|\n| Success | #22c55e | (34, 197, 94) | Completed, OK, checkmarks |\n| Warning | #f59e0b | (245, 158, 11) | Caution, attention needed |\n| Error | #ef4444 | (239, 68, 68) | Failures, errors, problems |\n| Info | #3b82f6 | (59, 130, 246) | Informational messages |\n\n### Neutral Palette (Text/Backgrounds)\n| Name | Hex | RGB | Purpose |\n|------|-----|-----|---------|\n| Text | #e5e7eb | (229, 231, 235) | Primary text content |\n| Text Muted | #9ca3af | (156, 163, 175) | Secondary text, timestamps |\n| Text Dim | #6b7280 | (107, 114, 128) | Tertiary text, hints |\n| Border | #374151 | (55, 65, 81) | Box borders, dividers |\n| Background | #1f2937 | (31, 41, 55) | Panel backgrounds |\n\n## Implementation\n\n### File: crates/fastmcp-console/src/theme.rs\n\n```rust\n//\\! FastMCP visual theme system.\n//\\!\n//\\! Provides a consistent color palette and style definitions\n//\\! for all rich terminal output throughout FastMCP.\n\nuse rich_rust::prelude::*;\nuse std::sync::OnceLock;\n\n/// The FastMCP color palette and style definitions\npub struct FastMcpTheme {\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // Primary Brand Colors\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    /// Vibrant cyan - main brand color\n    pub primary: Color,\n    /// Soft purple - accent and keys\n    pub secondary: Color,\n    /// Electric green - success and active\n    pub accent: Color,\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // Semantic Colors\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    /// Green - success, completion\n    pub success: Color,\n    /// Amber - warnings, caution\n    pub warning: Color,\n    /// Red - errors, failures\n    pub error: Color,\n    /// Blue - informational\n    pub info: Color,\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // Neutral Palette\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    /// Light gray - primary text\n    pub text: Color,\n    /// Medium gray - secondary text\n    pub text_muted: Color,\n    /// Dark gray - tertiary text\n    pub text_dim: Color,\n    /// Border color for boxes/tables\n    pub border: Color,\n    /// Panel background\n    pub background: Color,\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // Pre-composed Styles\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    /// Style for headers and titles\n    pub header_style: Style,\n    /// Style for subheaders\n    pub subheader_style: Style,\n    /// Style for labels/keys\n    pub label_style: Style,\n    /// Style for values\n    pub value_style: Style,\n    /// Style for important keys\n    pub key_style: Style,\n    /// Style for muted/dim text\n    pub muted_style: Style,\n    /// Style for success messages\n    pub success_style: Style,\n    /// Style for warning messages\n    pub warning_style: Style,\n    /// Style for error messages\n    pub error_style: Style,\n    /// Style for info messages\n    pub info_style: Style,\n    /// Style for borders\n    pub border_style: Style,\n}\n\nimpl FastMcpTheme {\n    /// Create a new theme with FastMCP's default colors\n    pub fn new() -> Self {\n        // Colors\n        let primary = Color::from_rgb(0, 212, 255);\n        let secondary = Color::from_rgb(168, 85, 247);\n        let accent = Color::from_rgb(34, 197, 94);\n        let success = Color::from_rgb(34, 197, 94);\n        let warning = Color::from_rgb(245, 158, 11);\n        let error = Color::from_rgb(239, 68, 68);\n        let info = Color::from_rgb(59, 130, 246);\n        let text = Color::from_rgb(229, 231, 235);\n        let text_muted = Color::from_rgb(156, 163, 175);\n        let text_dim = Color::from_rgb(107, 114, 128);\n        let border = Color::from_rgb(55, 65, 81);\n        let background = Color::from_rgb(31, 41, 55);\n\n        Self {\n            // Colors\n            primary: primary.clone(),\n            secondary: secondary.clone(),\n            accent: accent.clone(),\n            success: success.clone(),\n            warning: warning.clone(),\n            error: error.clone(),\n            info: info.clone(),\n            text: text.clone(),\n            text_muted: text_muted.clone(),\n            text_dim: text_dim.clone(),\n            border: border.clone(),\n            background,\n\n            // Pre-composed styles\n            header_style: Style::new().bold().color(primary.clone()),\n            subheader_style: Style::new().color(text_muted.clone()),\n            label_style: Style::new().color(text_dim.clone()),\n            value_style: Style::new().color(text),\n            key_style: Style::new().bold().color(secondary),\n            muted_style: Style::new().dim().color(text_dim),\n            success_style: Style::new().bold().color(success),\n            warning_style: Style::new().bold().color(warning),\n            error_style: Style::new().bold().color(error),\n            info_style: Style::new().color(info),\n            border_style: Style::new().color(border),\n        }\n    }\n\n    /// Get the primary color as a hex string for markup\n    pub fn primary_hex(&self) -> String {\n        self.primary.hex()\n    }\n\n    // Add similar helper methods for other colors...\n}\n\nimpl Default for FastMcpTheme {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Global theme accessor (lazy initialized)\nstatic THEME: OnceLock<FastMcpTheme> = OnceLock::new();\n\n/// Get the global FastMCP theme\npub fn theme() -> &'static FastMcpTheme {\n    THEME.get_or_init(FastMcpTheme::new)\n}\n\n/// Set a custom theme (must be called before any output)\npub fn set_theme(theme: FastMcpTheme) -> Result<(), FastMcpTheme> {\n    THEME.set(theme)\n}\n```\n\n## Why These Specific Colors?\n\n### Cyan (#00d4ff) as Primary\n- Evokes technology, digital, futuristic\n- High visibility on dark backgrounds\n- Distinct from standard terminal colors\n- Associated with \"high performance\" in tech branding\n\n### Purple (#a855f7) as Secondary\n- Complements cyan beautifully\n- Associated with creativity, intelligence\n- Makes keys/identifiers stand out\n- Popular in modern developer tools\n\n### Green (#22c55e) for Success\n- Universal color for \"go\", \"success\", \"complete\"\n- Distinct from the primary cyan\n- High contrast for visibility\n\n## Acceptance Criteria\n- [ ] All colors are defined as Color instances\n- [ ] All styles are pre-composed for performance\n- [ ] theme() returns a static reference (no allocation per call)\n- [ ] Colors work well on both dark and light terminals\n- [ ] Helper methods for hex strings are available\n- [ ] set_theme() allows customization before first use\n\n## Future Considerations\n- Could add light/dark mode variants\n- Could load theme from environment/config file\n- Could add more semantic styles as needed","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:05:07.014412491Z","created_by":"ubuntu","updated_at":"2026-01-20T02:59:45.352950004Z","closed_at":"2026-01-20T02:59:45.352903787Z","close_reason":"Implemented in initial crate creation","source_repo":".","compaction_level":0,"original_size":0,"labels":["foundation","phase-1","rich-rust","theme"],"dependencies":[{"issue_id":"bd-14i","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:05:07.056106974Z","created_by":"ubuntu"},{"issue_id":"bd-14i","depends_on_id":"bd-3h3","type":"blocks","created_at":"2026-01-19T21:05:57.219993688Z","created_by":"ubuntu"}]}
{"id":"bd-159","title":"Implement StatsRenderer for beautiful metrics display","description":"## Purpose and Rationale\n\nCreate a renderer that transforms ServerStats snapshots into beautiful rich_rust output - tables, panels, and formatted text that looks premium in the terminal.\n\n## Background\n\nRaw metrics are useful but not engaging. The StatsRenderer transforms cold numbers into a visually appealing dashboard-style display using rich_rust's Table, Panel, and styled text capabilities. This is what makes the server feel polished.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/stats/renderer.rs\n\nuse rich_rust::{Table, Panel, Column, JustifyMethod, Style};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse super::StatsSnapshot;\n\n/// Renders server statistics in various formats\npub struct StatsRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n}\n\nimpl StatsRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self { theme, context }\n    }\n    \n    /// Render a full statistics panel\n    pub fn render_panel(&self, stats: &StatsSnapshot, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(stats, console);\n            return;\n        }\n        \n        let content = self.build_stats_content(stats);\n        let panel = Panel::from_text(&content)\n            .title(\"Server Statistics\")\n            .width(60)\n            .style(self.theme.panel_border_style());\n        \n        console.print_renderable(&panel);\n    }\n    \n    /// Render as a compact table\n    pub fn render_table(&self, stats: &StatsSnapshot, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(stats, console);\n            return;\n        }\n        \n        let mut table = Table::new()\n            .title(\"Runtime Metrics\")\n            .with_column(Column::new(\"Metric\").style(self.theme.dim_style()))\n            .with_column(Column::new(\"Value\").justify(JustifyMethod::Right));\n        \n        // Uptime with formatted duration\n        table.add_row_cells([\"Uptime\", &self.format_duration(stats.uptime)]);\n        \n        // Request counts\n        table.add_row_cells([\"Total Requests\", &stats.total_requests.to_string()]);\n        table.add_row_cells([\n            \"Success Rate\",\n            &self.format_percentage(stats.successful_requests, stats.total_requests)\n        ]);\n        \n        // Breakdown by type\n        table.add_row_cells([\"  Tool Calls\", &stats.tool_calls.to_string()]);\n        table.add_row_cells([\"  Resource Reads\", &stats.resource_reads.to_string()]);\n        table.add_row_cells([\"  Prompt Gets\", &stats.prompt_gets.to_string()]);\n        \n        // Latency\n        table.add_row_cells([\"Avg Latency\", &self.format_latency(stats.avg_latency)]);\n        table.add_row_cells([\"Max Latency\", &self.format_latency(stats.max_latency)]);\n        \n        // Connections\n        table.add_row_cells([\"Active Connections\", &stats.active_connections.to_string()]);\n        \n        // Data transfer\n        table.add_row_cells([\"Data Received\", &self.format_bytes(stats.bytes_received)]);\n        table.add_row_cells([\"Data Sent\", &self.format_bytes(stats.bytes_sent)]);\n        \n        console.print_renderable(&table);\n    }\n    \n    /// Render a compact one-line summary\n    pub fn render_oneline(&self, stats: &StatsSnapshot, console: &FastMcpConsole) {\n        let line = if self.context.should_use_rich() {\n            format!(\n                \"[dim]â±[/] {} [dim]â”‚[/] [cyan]{}[/] reqs [dim]â”‚[/] [green]{:.1}%[/] ok [dim]â”‚[/] [yellow]{}[/] avg\",\n                self.format_duration(stats.uptime),\n                stats.total_requests,\n                self.success_rate(stats) * 100.0,\n                self.format_latency(stats.avg_latency)\n            )\n        } else {\n            format!(\n                \"Uptime: {} | Requests: {} | Success: {:.1}% | Avg latency: {}\",\n                self.format_duration(stats.uptime),\n                stats.total_requests,\n                self.success_rate(stats) * 100.0,\n                self.format_latency(stats.avg_latency)\n            )\n        };\n        \n        console.print(&line);\n    }\n    \n    // Helper methods\n    \n    fn format_duration(&self, d: Duration) -> String {\n        let secs = d.as_secs();\n        if secs < 60 {\n            format!(\"{}s\", secs)\n        } else if secs < 3600 {\n            format!(\"{}m {}s\", secs / 60, secs % 60)\n        } else {\n            format!(\"{}h {}m\", secs / 3600, (secs % 3600) / 60)\n        }\n    }\n    \n    fn format_latency(&self, d: Duration) -> String {\n        let micros = d.as_micros();\n        if micros < 1000 {\n            format!(\"{}Î¼s\", micros)\n        } else if micros < 1_000_000 {\n            format!(\"{:.1}ms\", micros as f64 / 1000.0)\n        } else {\n            format!(\"{:.2}s\", micros as f64 / 1_000_000.0)\n        }\n    }\n    \n    fn format_bytes(&self, bytes: u64) -> String {\n        const KB: u64 = 1024;\n        const MB: u64 = KB * 1024;\n        const GB: u64 = MB * 1024;\n        \n        if bytes < KB {\n            format!(\"{} B\", bytes)\n        } else if bytes < MB {\n            format!(\"{:.1} KB\", bytes as f64 / KB as f64)\n        } else if bytes < GB {\n            format!(\"{:.1} MB\", bytes as f64 / MB as f64)\n        } else {\n            format!(\"{:.2} GB\", bytes as f64 / GB as f64)\n        }\n    }\n    \n    fn format_percentage(&self, part: u64, total: u64) -> String {\n        if total == 0 {\n            \"N/A\".to_string()\n        } else {\n            format!(\"{:.1}%\", (part as f64 / total as f64) * 100.0)\n        }\n    }\n    \n    fn success_rate(&self, stats: &StatsSnapshot) -> f64 {\n        if stats.total_requests == 0 {\n            1.0\n        } else {\n            stats.successful_requests as f64 / stats.total_requests as f64\n        }\n    }\n    \n    fn render_plain(&self, stats: &StatsSnapshot, console: &FastMcpConsole) {\n        console.print(&format!(\"=== Server Statistics ===\"));\n        console.print(&format!(\"Uptime: {}\", self.format_duration(stats.uptime)));\n        console.print(&format!(\"Requests: {} total, {} successful, {} failed\",\n            stats.total_requests, stats.successful_requests, stats.failed_requests));\n        console.print(&format!(\"Latency: {} avg, {} max\",\n            self.format_latency(stats.avg_latency), self.format_latency(stats.max_latency)));\n    }\n}\n```\n\n## Implementation Steps\n\n1. Create stats/renderer.rs in crates/fastmcp-console/src/\n2. Implement render_panel() with full statistics\n3. Implement render_table() for compact table view\n4. Implement render_oneline() for status bar style\n5. Add all formatting helper methods\n6. Implement plain-text fallback\n7. Add visual tests (snapshot tests)\n\n## Acceptance Criteria\n\n- [ ] Panel rendering shows all key metrics\n- [ ] Table rendering is properly aligned\n- [ ] One-line summary is concise and readable\n- [ ] All durations format correctly (s/m/h)\n- [ ] All byte sizes format correctly (B/KB/MB/GB)\n- [ ] Percentages handle edge cases (0 requests)\n- [ ] Plain-text fallback is functional\n- [ ] Colors follow theme consistently\n\n## Visual Example (Rich Mode)\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Server Statistics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Metric             â”‚              Value           â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Uptime             â”‚                    2h 15m    â”‚\nâ”‚ Total Requests     â”‚                      1,234   â”‚\nâ”‚ Success Rate       â”‚                      98.5%   â”‚\nâ”‚   Tool Calls       â”‚                        892   â”‚\nâ”‚   Resource Reads   â”‚                        312   â”‚\nâ”‚   Prompt Gets      â”‚                         30   â”‚\nâ”‚ Avg Latency        â”‚                     12.3ms   â”‚\nâ”‚ Max Latency        â”‚                    156.2ms   â”‚\nâ”‚ Active Connections â”‚                          2   â”‚\nâ”‚ Data Received      â”‚                    4.2 MB    â”‚\nâ”‚ Data Sent          â”‚                   12.8 MB    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Dependencies\n\n- Requires ServerStats/StatsSnapshot (bd-6sq)\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:12:01.534856722Z","created_by":"ubuntu","updated_at":"2026-01-21T07:38:05.741668411Z","closed_at":"2026-01-21T07:38:05.740731386Z","close_reason":"Completed","source_repo":".","compaction_level":0,"original_size":0,"labels":["phase-4","rendering","rich-rust","stats"],"dependencies":[{"issue_id":"bd-159","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:12:33.303319168Z","created_by":"ubuntu"},{"issue_id":"bd-159","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:12:01.575745077Z","created_by":"ubuntu"},{"issue_id":"bd-159","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:12:33.110285374Z","created_by":"ubuntu"},{"issue_id":"bd-159","depends_on_id":"bd-6sq","type":"blocks","created_at":"2026-01-19T21:12:32.911704094Z","created_by":"ubuntu"}]}
{"id":"bd-197","title":"Implement RichErrorRenderer for styled error display","description":"## Purpose and Rationale\n\nCreate a sophisticated error rendering system that displays errors with full context, suggestions, and visual hierarchy using rich_rust. Errors should be informative, not scary - they should guide users toward solutions.\n\n## Background\n\nError display is where many CLI tools fail - they show cryptic messages that leave users confused. The RichErrorRenderer transforms FastMCP errors into beautiful, actionable displays with:\n- Clear error categorization\n- Contextual information\n- Suggested fixes\n- Stack traces (when appropriate)\n- Links to documentation\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/error/renderer.rs\n\nuse rich_rust::{Panel, Style, Color, Rule};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse fastmcp::error::Error;\n\n/// Renders errors in a beautiful, informative format\npub struct RichErrorRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n    show_suggestions: bool,\n    show_backtrace: bool,\n    show_error_code: bool,\n}\n\nimpl RichErrorRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            theme,\n            context,\n            show_suggestions: true,\n            show_backtrace: std::env::var(\"RUST_BACKTRACE\").is_ok(),\n            show_error_code: true,\n        }\n    }\n    \n    /// Render an error with full context\n    pub fn render(&self, error: &Error, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(error, console);\n            return;\n        }\n        \n        // Error header\n        let category = self.categorize_error(error);\n        self.render_header(category, console);\n        \n        // Main error panel\n        self.render_error_panel(error, console);\n        \n        // Suggestions\n        if self.show_suggestions {\n            if let Some(suggestions) = self.get_suggestions(error) {\n                self.render_suggestions(&suggestions, console);\n            }\n        }\n        \n        // Context/backtrace\n        if self.show_backtrace {\n            self.render_context(error, console);\n        }\n    }\n    \n    fn categorize_error(&self, error: &Error) -> ErrorCategory {\n        match error {\n            Error::Transport(_) => ErrorCategory::Connection,\n            Error::Protocol(_) => ErrorCategory::Protocol,\n            Error::Handler(_) => ErrorCategory::Handler,\n            Error::Timeout(_) => ErrorCategory::Timeout,\n            Error::Cancelled => ErrorCategory::Cancelled,\n            Error::Internal(_) => ErrorCategory::Internal,\n            _ => ErrorCategory::Unknown,\n        }\n    }\n    \n    fn render_header(&self, category: ErrorCategory, console: &FastMcpConsole) {\n        let (icon, label, style) = match category {\n            ErrorCategory::Connection => (\"ðŸ”Œ\", \"Connection Error\", self.theme.error_style()),\n            ErrorCategory::Protocol => (\"ðŸ“‹\", \"Protocol Error\", self.theme.error_style()),\n            ErrorCategory::Handler => (\"âš™ï¸\", \"Handler Error\", self.theme.warning_style()),\n            ErrorCategory::Timeout => (\"â±ï¸\", \"Timeout\", self.theme.warning_style()),\n            ErrorCategory::Cancelled => (\"âœ‹\", \"Cancelled\", self.theme.info_style()),\n            ErrorCategory::Internal => (\"ðŸ’¥\", \"Internal Error\", self.theme.error_style()),\n            ErrorCategory::Unknown => (\"âŒ\", \"Error\", self.theme.error_style()),\n        };\n        \n        let rule = Rule::with_title(&format!(\"{} {}\", icon, label))\n            .style(style);\n        console.print_renderable(&rule);\n    }\n    \n    fn render_error_panel(&self, error: &Error, console: &FastMcpConsole) {\n        let message = error.to_string();\n        let code = self.error_code(error);\n        \n        let content = if self.show_error_code {\n            format!(\"[bold]{}[/]\\n\\n{}\", code, message)\n        } else {\n            message\n        };\n        \n        let panel = Panel::from_text(&content)\n            .style(self.theme.error_border_style())\n            .padding(1);\n        \n        console.print_renderable(&panel);\n    }\n    \n    fn render_suggestions(&self, suggestions: &[String], console: &FastMcpConsole) {\n        console.print(\"\\n[bold cyan]ðŸ’¡ Suggestions:[/]\");\n        for (i, suggestion) in suggestions.iter().enumerate() {\n            console.print(&format!(\"  [dim]{}.[/] {}\", i + 1, suggestion));\n        }\n    }\n    \n    fn get_suggestions(&self, error: &Error) -> Option<Vec<String>> {\n        match error {\n            Error::Transport(msg) if msg.contains(\"connection refused\") => {\n                Some(vec![\n                    \"Check that the MCP client is running\".to_string(),\n                    \"Verify the transport configuration\".to_string(),\n                    \"Check firewall settings\".to_string(),\n                ])\n            }\n            Error::Protocol(msg) if msg.contains(\"unknown method\") => {\n                Some(vec![\n                    \"Verify the method name is correct\".to_string(),\n                    \"Check that the handler is registered\".to_string(),\n                    \"Run with RUST_LOG=debug for more details\".to_string(),\n                ])\n            }\n            Error::Timeout(_) => {\n                Some(vec![\n                    \"Increase the timeout value in configuration\".to_string(),\n                    \"Check for slow operations in handlers\".to_string(),\n                    \"Consider using async operations\".to_string(),\n                ])\n            }\n            _ => None,\n        }\n    }\n    \n    fn error_code(&self, error: &Error) -> String {\n        match error {\n            Error::Transport(_) => \"E001\".to_string(),\n            Error::Protocol(_) => \"E002\".to_string(),\n            Error::Handler(_) => \"E003\".to_string(),\n            Error::Timeout(_) => \"E004\".to_string(),\n            Error::Cancelled => \"E005\".to_string(),\n            Error::Internal(_) => \"E500\".to_string(),\n            _ => \"E000\".to_string(),\n        }\n    }\n    \n    fn render_plain(&self, error: &Error, console: &FastMcpConsole) {\n        console.print(&format!(\"ERROR: {}\", error));\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\nenum ErrorCategory {\n    Connection,\n    Protocol,\n    Handler,\n    Timeout,\n    Cancelled,\n    Internal,\n    Unknown,\n}\n```\n\n### Visual Example\n\n```\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ”Œ Connection Error â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ E001                                              â”‚\nâ”‚                                                   â”‚\nâ”‚ Failed to connect to transport: connection        â”‚\nâ”‚ refused (os error 111)                            â”‚\nâ”‚                                                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nðŸ’¡ Suggestions:\n  1. Check that the MCP client is running\n  2. Verify the transport configuration\n  3. Check firewall settings\n```\n\n## Implementation Steps\n\n1. Create error/mod.rs and error/renderer.rs\n2. Define ErrorCategory enum\n3. Implement render() with full error display\n4. Implement categorize_error() mapping\n5. Implement get_suggestions() with actionable advice\n6. Implement error_code() for reference codes\n7. Add plain-text fallback\n8. Test with various error types\n\n## Acceptance Criteria\n\n- [ ] All FastMCP error types are categorized\n- [ ] Each category has distinct visual styling\n- [ ] Suggestions are relevant and actionable\n- [ ] Error codes are assigned consistently\n- [ ] Backtrace display is conditional\n- [ ] Plain-text fallback is functional\n- [ ] No emoji in plain-text mode\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:13:14.454610552Z","created_by":"ubuntu","updated_at":"2026-01-20T03:01:57.650865466Z","closed_at":"2026-01-20T03:01:57.650815091Z","close_reason":"Implemented RichErrorRenderer","source_repo":".","compaction_level":0,"original_size":0,"labels":["errors","phase-5","rendering","rich-rust"],"dependencies":[{"issue_id":"bd-197","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:13:48.574826656Z","created_by":"ubuntu"},{"issue_id":"bd-197","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:13:14.494602990Z","created_by":"ubuntu"},{"issue_id":"bd-197","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:13:48.380907985Z","created_by":"ubuntu"},{"issue_id":"bd-197","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:13:48.773973140Z","created_by":"ubuntu"}]}
{"id":"bd-1c8","title":"Transport: implement SSE transport end-to-end","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T02:28:08.434429006Z","created_by":"ubuntu","updated_at":"2026-01-25T04:26:15.700123106Z","closed_at":"2026-01-25T04:26:15.700105693Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-1dx","title":"Add notes_server example","description":"Create a notes server example demonstrating resource handlers","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T01:13:20.554926452Z","created_by":"ubuntu","updated_at":"2026-01-19T01:14:50.205393746Z","closed_at":"2026-01-19T01:14:50.205352078Z","close_reason":"Notes server example already exists and is comprehensive (9 tools, 2 resources, 2 prompts)","source_repo":".","compaction_level":0,"original_size":0,"labels":["examples"]}
{"id":"bd-1e2","title":"Create integration test suite for component interoperability","description":"## Purpose and Rationale\n\nCreate integration tests that verify components work correctly together. While unit tests verify individual components and E2E tests verify the whole system, integration tests focus on component boundaries and interactions.\n\n## Background\n\nIntegration bugs often occur at boundaries between components:\n- Console + Theme interaction\n- Renderer + Console interaction  \n- DisplayContext affecting multiple components\n- Config affecting all subsystems\n\n## Test Scenarios\n\n### 1. Theme-Console Integration\n\n```rust\n#[test]\nfn test_theme_styles_applied_by_console() {\n    let theme = FastMcpTheme::builder()\n        .primary_color(\"#00ff00\")\n        .build()\n        .unwrap();\n    \n    let tc = TestConsole::new_with_theme(theme.clone());\n    tc.console().print(\"[primary]Test[/]\");\n    \n    // Verify the custom color was applied\n    let raw = tc.raw_output().join(\"\");\n    // Check for the ANSI code corresponding to #00ff00\n}\n```\n\n### 2. Renderer-Console Integration\n\n```rust\n#[test]\nfn test_error_renderer_uses_console_correctly() {\n    let tc = TestConsole::new_rich();\n    let renderer = RichErrorRenderer::new(\n        tc.console().theme().clone(),\n        tc.console().context().clone(),\n    );\n    \n    let error = Error::Internal(\"test\".into());\n    renderer.render(&error, tc.console());\n    \n    // Verify output went to the right place\n    assert!(!tc.output().is_empty());\n}\n\n#[test]\nfn test_multiple_renderers_share_console() {\n    let tc = TestConsole::new_rich();\n    \n    // Use multiple renderers with same console\n    let error_renderer = RichErrorRenderer::new(/* ... */);\n    let stats_renderer = StatsRenderer::new(/* ... */);\n    let tool_renderer = ToolTableRenderer::new(/* ... */);\n    \n    error_renderer.render(&Error::Internal(\"test\".into()), tc.console());\n    stats_renderer.render_table(&StatsSnapshot::default(), tc.console());\n    tool_renderer.render(&[], tc.console());\n    \n    // All output should be captured\n    tc.assert_contains(\"error\");\n    tc.assert_contains(\"No tools\");\n}\n```\n\n### 3. DisplayContext Propagation\n\n```rust\n#[test]\nfn test_agent_context_propagates_to_all_renderers() {\n    let context = DisplayContext::new_agent();\n    let theme = FastMcpTheme::default();\n    \n    let renderers = vec![\n        RichErrorRenderer::new(theme.clone(), context.clone()),\n        StatsRenderer::new(theme.clone(), context.clone()),\n        ToolTableRenderer::new(theme.clone(), context.clone()),\n    ];\n    \n    let tc = TestConsole::new(); // Agent mode\n    \n    for renderer in &renderers {\n        // Each renderer should respect agent context\n        // and not produce ANSI codes\n    }\n    \n    let raw = tc.raw_output().join(\"\");\n    assert!(!raw.contains(\"\\x1b[\"), \"Agent context should suppress all ANSI\");\n}\n```\n\n### 4. Config Propagation\n\n```rust\n#[test]\nfn test_config_affects_all_components() {\n    let config = ConsoleConfig::new()\n        .plain_mode()\n        .without_banner()\n        .without_suggestions();\n    \n    let context = config.resolve_context();\n    let theme = config.theme.clone();\n    \n    // Verify context is agent-like\n    assert!(!context.should_use_rich());\n    \n    // Verify error renderer respects show_suggestions\n    let renderer = RichErrorRenderer::new(theme, context);\n    // renderer should not show suggestions\n}\n```\n\n### 5. Logging Integration\n\n```rust\n#[test]\nfn test_rich_logging_integrates_with_console() {\n    let tc = TestConsole::new_rich();\n    \n    // Initialize logging to capture to test console\n    let subscriber = RichSubscriberBuilder::new()\n        .with_writer(tc.writer())\n        .build();\n    \n    tracing::subscriber::with_default(subscriber, || {\n        tracing::info!(\"Test log message\");\n        tracing::error!(\"Test error\");\n    });\n    \n    tc.assert_contains(\"Test log message\");\n    tc.assert_contains(\"Test error\");\n}\n```\n\n### 6. Stats Collection Integration\n\n```rust\n#[test]\nfn test_stats_collection_integrates_with_renderer() {\n    let stats = ServerStats::new();\n    \n    // Simulate server activity\n    for i in 0..100 {\n        let success = i % 10 != 0; // 90% success rate\n        stats.record_request(\"tools/call\", Duration::from_millis(10 + i), success);\n    }\n    \n    let snapshot = stats.snapshot();\n    \n    let tc = TestConsole::new();\n    let renderer = StatsRenderer::new(/* ... */);\n    renderer.render_table(&snapshot, tc.console());\n    \n    // Verify stats are accurately reflected\n    tc.assert_contains(\"100\"); // Total requests\n    tc.assert_contains(\"90\"); // Success count or percentage\n}\n```\n\n### 7. Handler Registry Integration\n\n```rust\n#[test]\nfn test_unified_handler_registry_uses_sub_renderers() {\n    let tc = TestConsole::new_rich();\n    \n    let tools = vec![/* sample tools */];\n    let resources = vec![/* sample resources */];\n    let prompts = vec![/* sample prompts */];\n    \n    let capabilities = ServerCapabilities { tools, resources, prompts };\n    \n    let registry_renderer = HandlerRegistryRenderer::new(/* ... */);\n    registry_renderer.render(&capabilities, tc.console());\n    \n    // Verify all sections rendered\n    tc.assert_contains(\"Tools\");\n    tc.assert_contains(\"Resources\");\n    tc.assert_contains(\"Prompts\");\n}\n```\n\n## Acceptance Criteria\n\n- [ ] All component boundaries are tested\n- [ ] Theme propagation verified\n- [ ] Context propagation verified\n- [ ] Config propagation verified\n- [ ] No cross-contamination between components\n- [ ] Tests are deterministic\n\n## Dependencies\n\n- Requires unit test suite (bd-1mh)\n- Requires all component implementations","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:25:52.091333113Z","created_by":"ubuntu","updated_at":"2026-01-21T10:50:47.637955757Z","closed_at":"2026-01-21T10:50:47.637912906Z","close_reason":"Created comprehensive integration test suite with 29 tests covering: Theme-Console integration, Renderer-Console integration (Error, Stats, Tool, Resource, Prompt, Client renderers), DisplayContext propagation, Config propagation, Error boundary integration, Stats collection integration, TestConsole functionality, and cross-component state independence. All tests pass.","source_repo":".","compaction_level":0,"original_size":0,"labels":["integration","quality","rich-rust","testing"],"dependencies":[{"issue_id":"bd-1e2","depends_on_id":"bd-1mh","type":"blocks","created_at":"2026-01-19T21:27:04.325370573Z","created_by":"ubuntu"},{"issue_id":"bd-1e2","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:25:52.134873193Z","created_by":"ubuntu"}]}
{"id":"bd-1eu","title":"Expose real per-request region creation for server registry","description":"Current server active-request registry uses synthetic RegionId values (RegionId::new_for_test). We need a real per-request region creation API in asupersync (or fastmcp wrapper) so request Cx carries a true region handle for cancellation/drain observability. Align with asupersync region model, update server to use real regions when available, and remove synthetic ids.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T10:30:43.199900410Z","created_by":"ubuntu","updated_at":"2026-01-25T10:56:00.774590098Z","closed_at":"2026-01-25T10:56:00.774569449Z","close_reason":"Request contexts now use Cx::for_request_with_budget; active request registry uses cx.region_id; background tasks use for_request Cx","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-1f9","title":"Add calculator_server example","description":"Create a fully documented calculator server example demonstrating tool usage","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T01:13:19.435499993Z","created_by":"ubuntu","updated_at":"2026-01-19T01:14:49.472824141Z","closed_at":"2026-01-19T01:14:49.472763908Z","close_reason":"Calculator server example already exists and is comprehensive (14 tools, 2 resources, 2 prompts)","source_repo":".","compaction_level":0,"original_size":0,"labels":["examples"]}
{"id":"bd-1kr","title":"Transport: implement WebSocket transport end-to-end","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T02:28:13.341874874Z","created_by":"ubuntu","updated_at":"2026-01-25T04:26:15.728017723Z","closed_at":"2026-01-25T04:26:15.727996112Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-1mh","title":"Create comprehensive unit test suite for fastmcp-console","description":"## Purpose and Rationale\n\nCreate a comprehensive unit test suite that covers ALL components of the fastmcp-console crate. Every public API should have tests, every edge case should be covered, and test output should be detailed enough to diagnose failures quickly.\n\n## Background\n\nUnit tests are the foundation of code quality. Each component (Theme, DisplayContext, Console, Formatters, Renderers) needs thorough testing. Tests must be fast, deterministic, and provide clear failure messages. This bead ensures we don't ship broken code.\n\n## Critical Requirements\n\n### Test Coverage Targets\n- **Line coverage**: â‰¥90%\n- **Branch coverage**: â‰¥85%\n- **Public API coverage**: 100%\n\n### Test Organization\n\n```\ncrates/fastmcp-console/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ ... (implementation)\nâ””â”€â”€ tests/\n    â”œâ”€â”€ unit/\n    â”‚   â”œâ”€â”€ mod.rs\n    â”‚   â”œâ”€â”€ theme_tests.rs\n    â”‚   â”œâ”€â”€ context_tests.rs\n    â”‚   â”œâ”€â”€ console_tests.rs\n    â”‚   â”œâ”€â”€ markup_tests.rs\n    â”‚   â”œâ”€â”€ color_tests.rs\n    â”‚   â””â”€â”€ segment_tests.rs\n    â”œâ”€â”€ renderers/\n    â”‚   â”œâ”€â”€ mod.rs\n    â”‚   â”œâ”€â”€ error_renderer_tests.rs\n    â”‚   â”œâ”€â”€ stats_renderer_tests.rs\n    â”‚   â”œâ”€â”€ tool_table_tests.rs\n    â”‚   â”œâ”€â”€ resource_table_tests.rs\n    â”‚   â”œâ”€â”€ prompt_table_tests.rs\n    â”‚   â”œâ”€â”€ banner_tests.rs\n    â”‚   â”œâ”€â”€ client_info_tests.rs\n    â”‚   â””â”€â”€ traffic_tests.rs\n    â””â”€â”€ logging/\n        â”œâ”€â”€ mod.rs\n        â”œâ”€â”€ formatter_tests.rs\n        â””â”€â”€ subscriber_tests.rs\n```\n\n## Detailed Test Specifications\n\n### 1. Theme Tests (theme_tests.rs)\n\n```rust\n#[cfg(test)]\nmod theme_tests {\n    use fastmcp_console::theme::FastMcpTheme;\n    use rich_rust::Style;\n    \n    #[test]\n    fn test_default_theme_has_all_styles() {\n        let theme = FastMcpTheme::default();\n        \n        // Verify all style methods return valid styles\n        assert!(theme.primary_style().has_color());\n        assert!(theme.secondary_style().has_color());\n        assert!(theme.success_style().has_color());\n        assert!(theme.warning_style().has_color());\n        assert!(theme.error_style().has_color());\n        assert!(theme.info_style().has_color());\n        assert!(theme.debug_style().has_color());\n        assert!(theme.dim_style().is_dim());\n    }\n    \n    #[test]\n    fn test_theme_color_consistency() {\n        let theme = FastMcpTheme::default();\n        \n        // Error should be red-ish\n        let error_color = theme.error_style().foreground().unwrap();\n        assert!(error_color.is_red_family(), \"Error color should be in red family\");\n        \n        // Success should be green-ish\n        let success_color = theme.success_style().foreground().unwrap();\n        assert!(success_color.is_green_family(), \"Success color should be in green family\");\n        \n        // Warning should be yellow/orange\n        let warning_color = theme.warning_style().foreground().unwrap();\n        assert!(warning_color.is_yellow_family(), \"Warning color should be in yellow family\");\n    }\n    \n    #[test]\n    fn test_theme_clone_is_identical() {\n        let theme1 = FastMcpTheme::default();\n        let theme2 = theme1.clone();\n        \n        assert_eq!(\n            theme1.primary_style().to_markup(),\n            theme2.primary_style().to_markup()\n        );\n    }\n    \n    #[test]\n    fn test_custom_theme_builder() {\n        let theme = FastMcpTheme::builder()\n            .primary_color(\"#00ff00\")\n            .error_color(\"#ff0000\")\n            .build()\n            .expect(\"Theme should build\");\n        \n        // Verify custom colors applied\n    }\n    \n    #[test]\n    fn test_theme_accessibility_contrast() {\n        let theme = FastMcpTheme::default();\n        \n        // Ensure foreground/background combinations have adequate contrast\n        // for readability (WCAG AA minimum 4.5:1)\n        // This is a quality check, not a hard failure\n    }\n}\n```\n\n### 2. DisplayContext Tests (context_tests.rs)\n\n```rust\n#[cfg(test)]\nmod context_tests {\n    use fastmcp_console::context::DisplayContext;\n    use std::env;\n    \n    #[test]\n    fn test_agent_context_disables_rich() {\n        let ctx = DisplayContext::new_agent();\n        assert!(!ctx.should_use_rich());\n        assert!(!ctx.should_use_colors());\n        assert!(!ctx.should_use_emoji());\n    }\n    \n    #[test]\n    fn test_human_context_enables_rich() {\n        let ctx = DisplayContext::new_human();\n        assert!(ctx.should_use_rich());\n        assert!(ctx.should_use_colors());\n    }\n    \n    #[test]\n    fn test_detect_respects_mcp_client_env() {\n        // Save and restore env\n        let original = env::var(\"MCP_CLIENT\").ok();\n        \n        env::set_var(\"MCP_CLIENT\", \"claude-desktop\");\n        let ctx = DisplayContext::detect();\n        assert!(!ctx.should_use_rich(), \"MCP_CLIENT should trigger agent mode\");\n        \n        // Restore\n        if let Some(v) = original {\n            env::set_var(\"MCP_CLIENT\", v);\n        } else {\n            env::remove_var(\"MCP_CLIENT\");\n        }\n    }\n    \n    #[test]\n    fn test_detect_respects_no_color_env() {\n        let original = env::var(\"NO_COLOR\").ok();\n        \n        env::set_var(\"NO_COLOR\", \"1\");\n        let ctx = DisplayContext::detect();\n        assert!(!ctx.should_use_colors(), \"NO_COLOR should disable colors\");\n        \n        if let Some(v) = original {\n            env::set_var(\"NO_COLOR\", v);\n        } else {\n            env::remove_var(\"NO_COLOR\");\n        }\n    }\n    \n    #[test]\n    fn test_detect_respects_force_color_env() {\n        // Test FORCE_COLOR=1 overrides even when stdout is not a TTY\n    }\n    \n    #[test]\n    fn test_context_is_clone_and_debug() {\n        let ctx = DisplayContext::new_human();\n        let _cloned = ctx.clone();\n        let _debug = format!(\"{:?}\", ctx);\n    }\n}\n```\n\n### 3. Console Tests (console_tests.rs)\n\n```rust\n#[cfg(test)]\nmod console_tests {\n    use fastmcp_console::{FastMcpConsole, FastMcpTheme, DisplayContext};\n    use fastmcp_console::testing::TestConsole;\n    \n    #[test]\n    fn test_console_print_basic() {\n        let tc = TestConsole::new();\n        tc.console().print(\"Hello, world!\");\n        tc.assert_contains(\"Hello, world!\");\n    }\n    \n    #[test]\n    fn test_console_print_styled_in_human_mode() {\n        let tc = TestConsole::new_rich();\n        tc.console().print(\"[bold red]Error[/]\");\n        \n        // Should contain the text\n        tc.assert_contains(\"Error\");\n        \n        // Raw output should have ANSI codes\n        let raw = tc.raw_output().join(\"\");\n        assert!(raw.contains(\"\\x1b[\"), \"Rich mode should produce ANSI codes\");\n    }\n    \n    #[test]\n    fn test_console_print_plain_in_agent_mode() {\n        let tc = TestConsole::new(); // Agent mode by default\n        tc.console().print(\"[bold red]Error[/]\");\n        \n        // Should just have plain text\n        let raw = tc.raw_output().join(\"\");\n        assert!(!raw.contains(\"\\x1b[\"), \"Agent mode should not produce ANSI codes\");\n    }\n    \n    #[test]\n    fn test_console_print_renderable() {\n        use rich_rust::Panel;\n        \n        let tc = TestConsole::new_rich();\n        let panel = Panel::from_text(\"Content\").title(\"Title\");\n        tc.console().print_renderable(&panel);\n        \n        tc.assert_contains(\"Content\");\n        tc.assert_contains(\"Title\");\n    }\n    \n    #[test]\n    fn test_console_rule() {\n        let tc = TestConsole::new_rich();\n        tc.console().rule(Some(\"Section\"));\n        \n        tc.assert_contains(\"Section\");\n        // Should have box-drawing characters\n    }\n    \n    #[test]\n    fn test_console_width_default() {\n        let console = FastMcpConsole::new();\n        let width = console.width();\n        assert!(width > 0, \"Width should be positive\");\n        assert!(width <= 500, \"Width should be reasonable\");\n    }\n}\n```\n\n### 4. Error Renderer Tests (error_renderer_tests.rs)\n\n```rust\n#[cfg(test)]\nmod error_renderer_tests {\n    use fastmcp_console::error::RichErrorRenderer;\n    use fastmcp_console::testing::TestConsole;\n    use fastmcp::Error;\n    \n    #[test]\n    fn test_render_transport_error() {\n        let tc = TestConsole::new();\n        let renderer = RichErrorRenderer::new(/* ... */);\n        \n        let error = Error::Transport(\"connection refused\".into());\n        renderer.render(&error, tc.console());\n        \n        tc.assert_contains(\"Connection Error\");\n        tc.assert_contains(\"connection refused\");\n        \n        // Should have suggestions\n        tc.assert_contains(\"Suggestions\");\n        tc.assert_contains(\"Check that the MCP client is running\");\n    }\n    \n    #[test]\n    fn test_render_timeout_error() {\n        let tc = TestConsole::new();\n        let renderer = RichErrorRenderer::new(/* ... */);\n        \n        let error = Error::Timeout(std::time::Duration::from_secs(30));\n        renderer.render(&error, tc.console());\n        \n        tc.assert_contains(\"Timeout\");\n    }\n    \n    #[test]\n    fn test_render_all_error_types() {\n        // Test every Error variant is handled without panic\n        let tc = TestConsole::new();\n        let renderer = RichErrorRenderer::new(/* ... */);\n        \n        let errors = vec![\n            Error::Transport(\"test\".into()),\n            Error::Protocol(\"test\".into()),\n            Error::Handler(\"test\".into()),\n            Error::Timeout(std::time::Duration::from_secs(1)),\n            Error::Cancelled,\n            Error::Internal(\"test\".into()),\n        ];\n        \n        for error in errors {\n            tc.clear();\n            renderer.render(&error, tc.console());\n            assert!(!tc.output().is_empty(), \"Should produce output for {:?}\", error);\n        }\n    }\n    \n    #[test]\n    fn test_error_codes_are_unique() {\n        // Each error type should have a unique code\n    }\n    \n    #[test]\n    fn test_plain_mode_no_ansi() {\n        let tc = TestConsole::new(); // Agent/plain mode\n        let renderer = RichErrorRenderer::new(/* agent context */);\n        \n        let error = Error::Internal(\"test\".into());\n        renderer.render(&error, tc.console());\n        \n        let raw = tc.raw_output().join(\"\");\n        assert!(!raw.contains(\"\\x1b[\"), \"Plain mode should not have ANSI\");\n    }\n}\n```\n\n### 5. Stats Renderer Tests (stats_renderer_tests.rs)\n\n```rust\n#[cfg(test)]\nmod stats_renderer_tests {\n    use fastmcp_console::stats::{ServerStats, StatsSnapshot, StatsRenderer};\n    use fastmcp_console::testing::TestConsole;\n    use std::time::Duration;\n    \n    #[test]\n    fn test_render_empty_stats() {\n        let tc = TestConsole::new();\n        let renderer = StatsRenderer::new(/* ... */);\n        let stats = StatsSnapshot::default();\n        \n        renderer.render_table(&stats, tc.console());\n        \n        tc.assert_contains(\"0\"); // Zero requests\n    }\n    \n    #[test]\n    fn test_render_with_data() {\n        let stats = ServerStats::new();\n        \n        // Record some activity\n        stats.record_request(\"tools/call\", Duration::from_millis(50), true);\n        stats.record_request(\"resources/read\", Duration::from_millis(30), true);\n        stats.record_request(\"tools/call\", Duration::from_millis(100), false);\n        \n        let snapshot = stats.snapshot();\n        \n        let tc = TestConsole::new();\n        let renderer = StatsRenderer::new(/* ... */);\n        renderer.render_table(&snapshot, tc.console());\n        \n        tc.assert_contains(\"3\"); // Total requests\n        tc.assert_contains(\"66.7%\"); // Success rate (2/3)\n    }\n    \n    #[test]\n    fn test_duration_formatting() {\n        let renderer = StatsRenderer::new(/* ... */);\n        \n        // Verify duration formatting at various scales\n        assert_eq!(renderer.format_duration(Duration::from_secs(30)), \"30s\");\n        assert_eq!(renderer.format_duration(Duration::from_secs(90)), \"1m 30s\");\n        assert_eq!(renderer.format_duration(Duration::from_secs(3661)), \"1h 1m\");\n    }\n    \n    #[test]\n    fn test_bytes_formatting() {\n        let renderer = StatsRenderer::new(/* ... */);\n        \n        assert_eq!(renderer.format_bytes(500), \"500 B\");\n        assert_eq!(renderer.format_bytes(1024), \"1.0 KB\");\n        assert_eq!(renderer.format_bytes(1_500_000), \"1.4 MB\");\n    }\n    \n    #[test]\n    fn test_oneline_summary() {\n        let stats = ServerStats::new();\n        stats.record_request(\"tools/call\", Duration::from_millis(10), true);\n        \n        let tc = TestConsole::new();\n        let renderer = StatsRenderer::new(/* ... */);\n        renderer.render_oneline(&stats.snapshot(), tc.console());\n        \n        // Should be a single concise line\n        assert_eq!(tc.output().len(), 1);\n    }\n}\n```\n\n### 6. Handler Table Tests\n\n```rust\n// tool_table_tests.rs, resource_table_tests.rs, prompt_table_tests.rs\n// Similar pattern for each...\n\n#[cfg(test)]\nmod tool_table_tests {\n    use fastmcp_console::handlers::ToolTableRenderer;\n    use fastmcp_console::testing::TestConsole;\n    use fastmcp::tool::ToolInfo;\n    \n    #[test]\n    fn test_empty_tool_list() {\n        let tc = TestConsole::new();\n        let renderer = ToolTableRenderer::new(/* ... */);\n        \n        renderer.render(&[], tc.console());\n        tc.assert_contains(\"No tools registered\");\n    }\n    \n    #[test]\n    fn test_single_tool() {\n        let tc = TestConsole::new();\n        let renderer = ToolTableRenderer::new(/* ... */);\n        \n        let tools = vec![\n            ToolInfo {\n                name: \"calculate\".to_string(),\n                description: \"Perform math\".to_string(),\n                parameters: vec![],\n                return_type: None,\n            }\n        ];\n        \n        renderer.render(&tools, tc.console());\n        tc.assert_contains(\"calculate\");\n        tc.assert_contains(\"Perform math\");\n    }\n    \n    #[test]\n    fn test_tool_with_parameters() {\n        // Test tools with various parameter configurations\n    }\n    \n    #[test]\n    fn test_long_description_truncation() {\n        // Descriptions over max_width should be truncated with ...\n    }\n    \n    #[test]\n    fn test_detail_view() {\n        // Test render_detail() method\n    }\n}\n```\n\n## Test Infrastructure Requirements\n\n### Test Utilities Module\n\n```rust\n// crates/fastmcp-console/src/testing/mod.rs\n\npub mod test_console;\npub mod snapshots;\npub mod fixtures;\npub mod assertions;\n\npub use test_console::TestConsole;\npub use snapshots::SnapshotTest;\n\n/// Common test fixtures\npub mod fixtures {\n    use fastmcp::tool::ToolInfo;\n    \n    pub fn sample_tools() -> Vec<ToolInfo> {\n        vec![\n            ToolInfo {\n                name: \"calculate\".to_string(),\n                description: \"Perform mathematical calculations\".to_string(),\n                parameters: vec![/* ... */],\n                return_type: Some(\"number\".to_string()),\n            },\n            // More sample tools...\n        ]\n    }\n    \n    pub fn sample_resources() -> Vec<ResourceInfo> { /* ... */ }\n    pub fn sample_prompts() -> Vec<PromptInfo> { /* ... */ }\n}\n\n/// Custom assertions for rich output testing\npub mod assertions {\n    use super::TestConsole;\n    \n    pub fn assert_has_table(tc: &TestConsole, title: &str) {\n        tc.assert_contains(title);\n        // Verify table structure characters\n    }\n    \n    pub fn assert_has_panel(tc: &TestConsole, title: &str) {\n        tc.assert_contains(title);\n        // Verify panel border characters\n    }\n}\n```\n\n## Test Running and Reporting\n\n### Cargo Test Configuration\n\n```toml\n# crates/fastmcp-console/Cargo.toml\n\n[dev-dependencies]\npretty_assertions = \"1.4\"\ntest-case = \"3.3\"\nproptest = \"1.4\"\n\n[features]\ntest-utils = []\n\n[[test]]\nname = \"unit_tests\"\npath = \"tests/unit/mod.rs\"\n\n[[test]]\nname = \"renderer_tests\"\npath = \"tests/renderers/mod.rs\"\n```\n\n### Running Tests\n\n```bash\n# Run all tests with output\ncargo test -p fastmcp-console -- --nocapture\n\n# Run specific test module\ncargo test -p fastmcp-console theme_tests\n\n# Run with coverage\ncargo tarpaulin -p fastmcp-console --out Html\n\n# Run tests with logging\nRUST_LOG=debug cargo test -p fastmcp-console\n```\n\n## Acceptance Criteria\n\n- [ ] â‰¥90% line coverage measured by tarpaulin\n- [ ] Every public function has at least one test\n- [ ] Every error path has a test\n- [ ] Tests pass in CI (both debug and release mode)\n- [ ] Tests complete in <30 seconds total\n- [ ] No flaky tests (run 10x to verify)\n- [ ] Test output is clean (no warnings)\n- [ ] Snapshot tests exist for complex renderers\n\n## Dependencies\n\n- Requires TestConsole (bd-2gz)\n- Requires all component implementations to be complete\n- Should be run after each implementation phase","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:24:05.621341253Z","created_by":"ubuntu","updated_at":"2026-01-20T04:08:33.336261365Z","closed_at":"2026-01-20T04:08:33.336178509Z","close_reason":"Added 26 unit tests across config.rs, detection.rs, theme.rs, and console.rs - all passing","source_repo":".","compaction_level":0,"original_size":0,"labels":["quality","rich-rust","testing","unit-tests"],"dependencies":[{"issue_id":"bd-1mh","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:24:05.656533499Z","created_by":"ubuntu"},{"issue_id":"bd-1mh","depends_on_id":"bd-3op","type":"blocks","created_at":"2026-01-19T21:27:01.960394068Z","created_by":"ubuntu"}]}
{"id":"bd-1nk","title":"Implement ClientInfoRenderer for connection display","description":"## Purpose and Rationale\n\nCreate a renderer that displays connected client information in a beautiful format. When clients connect or disconnect, operators should see clear, informative status updates.\n\n## Background\n\nMCP servers handle connections from various clients (Claude Desktop, VS Code extensions, custom clients). Displaying client information - name, version, capabilities - helps operators understand who is connected and what they can do.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/client/info.rs\n\nuse rich_rust::{Panel, Table, Column, Rule, JustifyMethod};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse fastmcp::protocol::{ClientInfo, Implementation};\n\n/// Renders client information beautifully\npub struct ClientInfoRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n}\n\nimpl ClientInfoRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self { theme, context }\n    }\n    \n    /// Render client connection notification\n    pub fn render_connected(&self, client: &ClientInfo, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_connected_plain(client, console);\n            return;\n        }\n        \n        let icon = \"ðŸ”—\";\n        let client_name = client.name.as_deref().unwrap_or(\"Unknown Client\");\n        let version = client.version.as_deref().unwrap_or(\"?\");\n        \n        // Connection notification\n        console.print(&format!(\n            \"\\n{} [bold green]Client Connected[/]: [cyan]{}[/] [dim]v{}[/]\",\n            icon, client_name, version\n        ));\n        \n        // Capabilities panel (if any)\n        if self.has_capabilities(client) {\n            self.render_capabilities(client, console);\n        }\n    }\n    \n    /// Render client disconnection notification\n    pub fn render_disconnected(&self, client: &ClientInfo, reason: Option<&str>, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_disconnected_plain(client, reason, console);\n            return;\n        }\n        \n        let client_name = client.name.as_deref().unwrap_or(\"Unknown Client\");\n        \n        let msg = if let Some(r) = reason {\n            format!(\n                \"ðŸ”Œ [yellow]Client Disconnected[/]: [cyan]{}[/] [dim]({})[/]\",\n                client_name, r\n            )\n        } else {\n            format!(\"ðŸ”Œ [yellow]Client Disconnected[/]: [cyan]{}[/]\", client_name)\n        };\n        \n        console.print(&msg);\n    }\n    \n    /// Render detailed client info panel\n    pub fn render_detail(&self, client: &ClientInfo, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_detail_plain(client, console);\n            return;\n        }\n        \n        let mut table = Table::new()\n            .title(\"Connected Client\")\n            .with_column(Column::new(\"Property\").style(self.theme.dim_style()))\n            .with_column(Column::new(\"Value\"));\n        \n        table.add_row_cells([\"Name\", client.name.as_deref().unwrap_or(\"Unknown\")]);\n        table.add_row_cells([\"Version\", client.version.as_deref().unwrap_or(\"Unknown\")]);\n        \n        if let Some(impl_info) = &client.implementation {\n            table.add_row_cells([\"Implementation\", &impl_info.name]);\n            if let Some(v) = &impl_info.version {\n                table.add_row_cells([\"Impl Version\", v]);\n            }\n        }\n        \n        // Capabilities\n        if let Some(caps) = &client.capabilities {\n            let caps_str = self.format_capabilities_short(caps);\n            table.add_row_cells([\"Capabilities\", &caps_str]);\n        }\n        \n        console.print_renderable(&table);\n    }\n    \n    fn render_capabilities(&self, client: &ClientInfo, console: &FastMcpConsole) {\n        if let Some(caps) = &client.capabilities {\n            let mut items = Vec::new();\n            \n            if caps.roots.unwrap_or(false) {\n                items.push(\"ðŸ“ Roots\");\n            }\n            if caps.sampling.unwrap_or(false) {\n                items.push(\"ðŸŽ² Sampling\");\n            }\n            if caps.experimental.is_some() {\n                items.push(\"ðŸ§ª Experimental\");\n            }\n            \n            if !items.is_empty() {\n                console.print(&format!(\"  [dim]Capabilities: {}[/]\", items.join(\", \")));\n            }\n        }\n    }\n    \n    fn format_capabilities_short(&self, caps: &ClientCapabilities) -> String {\n        let mut items = Vec::new();\n        if caps.roots.unwrap_or(false) { items.push(\"roots\"); }\n        if caps.sampling.unwrap_or(false) { items.push(\"sampling\"); }\n        if caps.experimental.is_some() { items.push(\"experimental\"); }\n        \n        if items.is_empty() {\n            \"none\".to_string()\n        } else {\n            items.join(\", \")\n        }\n    }\n    \n    fn has_capabilities(&self, client: &ClientInfo) -> bool {\n        client.capabilities.as_ref().map(|c| {\n            c.roots.unwrap_or(false) || \n            c.sampling.unwrap_or(false) || \n            c.experimental.is_some()\n        }).unwrap_or(false)\n    }\n    \n    fn render_connected_plain(&self, client: &ClientInfo, console: &FastMcpConsole) {\n        let name = client.name.as_deref().unwrap_or(\"Unknown\");\n        let version = client.version.as_deref().unwrap_or(\"?\");\n        console.print(&format!(\"Client Connected: {} v{}\", name, version));\n    }\n    \n    fn render_disconnected_plain(&self, client: &ClientInfo, reason: Option<&str>, console: &FastMcpConsole) {\n        let name = client.name.as_deref().unwrap_or(\"Unknown\");\n        if let Some(r) = reason {\n            console.print(&format!(\"Client Disconnected: {} ({})\", name, r));\n        } else {\n            console.print(&format!(\"Client Disconnected: {}\", name));\n        }\n    }\n    \n    fn render_detail_plain(&self, client: &ClientInfo, console: &FastMcpConsole) {\n        console.print(\"Connected Client:\");\n        console.print(&format!(\"  Name: {}\", client.name.as_deref().unwrap_or(\"Unknown\")));\n        console.print(&format!(\"  Version: {}\", client.version.as_deref().unwrap_or(\"Unknown\")));\n    }\n}\n```\n\n### Visual Example\n\n```\nðŸ”— Client Connected: Claude Desktop v1.2.3\n  Capabilities: roots, sampling\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Connected Client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Property       â”‚ Value                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Name           â”‚ Claude Desktop                      â”‚\nâ”‚ Version        â”‚ 1.2.3                               â”‚\nâ”‚ Implementation â”‚ claude-desktop                      â”‚\nâ”‚ Capabilities   â”‚ roots, sampling                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Implementation Steps\n\n1. Create client/info.rs\n2. Implement render_connected() notification\n3. Implement render_disconnected() notification\n4. Implement render_detail() for full info\n5. Add capabilities formatting\n6. Implement plain-text fallbacks\n7. Test with various client info\n\n## Acceptance Criteria\n\n- [ ] Connection notification shows client name/version\n- [ ] Disconnection notification includes reason if provided\n- [ ] Detail view shows all client properties\n- [ ] Capabilities are formatted clearly\n- [ ] Plain-text fallback works correctly\n- [ ] Handles missing optional fields gracefully\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:16:46.003986354Z","created_by":"ubuntu","updated_at":"2026-01-21T10:51:35.572152346Z","closed_at":"2026-01-21T10:51:35.572078757Z","close_reason":"ClientInfoRenderer fully implemented in client.rs with: render_connected(), render_connected_with_caps(), render_disconnected(), render_disconnected_with_reason(), render_detail(), render_detail_with_caps(), format_capabilities(), all plain-text fallback variants, and comprehensive tests for all methods. All acceptance criteria met.","source_repo":".","compaction_level":0,"original_size":0,"labels":["client","connections","phase-7","rich-rust"],"dependencies":[{"issue_id":"bd-1nk","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:17:27.530461515Z","created_by":"ubuntu"},{"issue_id":"bd-1nk","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:16:46.042656292Z","created_by":"ubuntu"},{"issue_id":"bd-1nk","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:17:27.286846806Z","created_by":"ubuntu"},{"issue_id":"bd-1nk","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:17:27.773566604Z","created_by":"ubuntu"}]}
{"id":"bd-1xm","title":"Implement basic middleware system","description":"Implement a basic middleware system with explicit hook points for request/response interception (pre-request, post-response, error). Define a Middleware trait, ordering semantics, and integration points across tool/resource/prompt handlers; design with future auth/logging/rate-limit middleware in mind per EXISTING_FASTMCP_STRUCTURE.md.","acceptance_criteria":"Middleware trait + hook ordering documented and enforced; supports short-circuiting or transforming responses. Server wiring applies middleware uniformly across request types. Unit tests verify ordering, short-circuit behavior, and error propagation. Integration tests use a sample middleware stack to validate request/response mutation. E2E script runs server with middleware enabled and logs hook invocation order + payload mutations.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-25T02:51:25.243278267Z","created_by":"ubuntu","updated_at":"2026-01-25T12:17:07.285381958Z","closed_at":"2026-01-25T12:17:07.285364565Z","close_reason":"Implemented middleware ordering semantics, short-circuit/error handling, response mutation tests, and e2e logging","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-21p","title":"Protocol coverage: logging/setLevel handling + log notifications","description":"Implement logging/setLevel handling and log notifications: support client-set log level, map to server logging backend, and emit MCP log notifications with severity, message, and optional metadata per EXISTING_FASTMCP_STRUCTURE.md.","acceptance_criteria":"Protocol types for logging/setLevel and log notifications added with serde tests. Server applies level updates per session and filters emitted logs accordingly. Integration tests verify setLevel changes notification behavior and payload formatting. E2E script sets log level, runs a sample tool, and logs emitted notifications end-to-end.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:27:50.889906675Z","created_by":"ubuntu","updated_at":"2026-01-25T11:55:51.459326752Z","closed_at":"2026-01-25T11:55:51.459309199Z","close_reason":"Completed: per-session log level + notifications, filtering + tests","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-21s","title":"Add session state support (get_state/set_state)","description":"Python FastMCP Context has get_state() and set_state() for per-session state storage. McpContext should support this via the Session object.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-25T03:24:28.401706332Z","created_by":"ubuntu","updated_at":"2026-01-25T04:43:52.776040565Z","closed_at":"2026-01-25T04:43:52.776023352Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-237","title":"Background tasks: implement Docket/SEP-1686 task manager","description":"Implement Docket/SEP-1686 task manager: in-memory registry for background tasks, state machine (pending/running/completed/failed/cancelled), progress updates, and cancellation hooks wired into asupersync regions.","acceptance_criteria":"Task manager API supports create/list/get/cancel with thread-safe access. State transitions are validated and logged; cancellation propagates to task region. Unit tests cover lifecycle transitions and concurrent access. Integration tests validate task manager backing for tasks/* endpoints. E2E script exercises task manager via server APIs and logs state transitions with timestamps.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T02:28:19.574611240Z","created_by":"ubuntu","updated_at":"2026-01-25T11:39:54.348541504Z","closed_at":"2026-01-25T11:39:54.348523931Z","close_reason":"Completed: task manager transitions/logging, cancel propagation, tasks/* integration + E2E logging","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-239","title":"Create PROPOSED_RUST_ARCHITECTURE.md","description":"Create the missing PROPOSED_RUST_ARCHITECTURE.md to document the current Rust architecture and how it maps to the spec (EXISTING_FASTMCP_STRUCTURE.md) and crate layout. Include core modules, data flow, and integration points (asupersync, protocol, transport, server, macros, console).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T16:59:54.810488888Z","created_by":"ubuntu","updated_at":"2026-01-21T17:05:25.549074818Z","closed_at":"2026-01-21T17:05:25.547508566Z","close_reason":"Completed","source_repo":".","compaction_level":0,"original_size":0,"labels":["docs"]}
{"id":"bd-294","title":"Create end-to-end test suite with detailed logging","description":"## Purpose and Rationale\n\nCreate a comprehensive end-to-end test suite that validates the entire rich console system works correctly in realistic scenarios. E2E tests catch integration issues that unit tests miss and verify the user experience is correct.\n\n## Background\n\nE2E tests for console output are tricky because they depend on terminal state. This suite uses subprocess spawning to test the actual binary output, capturing both stdout and stderr to verify correct stream separation and rich formatting.\n\n## Critical Requirements\n\n### Test Scenarios\n\n1. **Server Lifecycle Test**: Start server â†’ show banner â†’ handle requests â†’ display stats â†’ shutdown\n2. **Error Handling Test**: Trigger various errors and verify display\n3. **Agent Mode Test**: Run with MCP_CLIENT set, verify no ANSI codes\n4. **Human Mode Test**: Run without agent env vars, verify rich output\n5. **Configuration Test**: Test all ConsoleConfig options\n\n### Test Infrastructure\n\n```\ntests/\nâ”œâ”€â”€ e2e/\nâ”‚   â”œâ”€â”€ mod.rs\nâ”‚   â”œâ”€â”€ helpers.rs          # Test utilities\nâ”‚   â”œâ”€â”€ server_lifecycle.rs # Full server tests\nâ”‚   â”œâ”€â”€ error_display.rs    # Error rendering tests\nâ”‚   â”œâ”€â”€ agent_mode.rs       # Agent-specific tests\nâ”‚   â”œâ”€â”€ human_mode.rs       # Human-specific tests\nâ”‚   â””â”€â”€ configuration.rs    # Config option tests\nâ””â”€â”€ fixtures/\n    â”œâ”€â”€ test_server.rs      # Minimal test server\n    â””â”€â”€ mock_client.rs      # MCP client simulator\n```\n\n## Detailed Test Specifications\n\n### Test Helper Module (helpers.rs)\n\n```rust\n// tests/e2e/helpers.rs\n\nuse std::process::{Command, Output, Stdio};\nuse std::time::Duration;\nuse std::io::{Write, BufRead, BufReader};\nuse std::thread;\n\n/// Configuration for E2E test runs\npub struct E2ETestConfig {\n    pub timeout: Duration,\n    pub env_vars: Vec<(String, String)>,\n    pub clear_env: Vec<String>,\n    pub capture_stderr: bool,\n    pub capture_stdout: bool,\n}\n\nimpl Default for E2ETestConfig {\n    fn default() -> Self {\n        Self {\n            timeout: Duration::from_secs(30),\n            env_vars: vec![],\n            clear_env: vec![\"MCP_CLIENT\".into(), \"CLAUDE_CODE\".into()],\n            capture_stderr: true,\n            capture_stdout: true,\n        }\n    }\n}\n\nimpl E2ETestConfig {\n    pub fn agent_mode() -> Self {\n        Self {\n            env_vars: vec![(\"MCP_CLIENT\".into(), \"test-agent\".into())],\n            ..Default::default()\n        }\n    }\n    \n    pub fn human_mode() -> Self {\n        Self {\n            env_vars: vec![(\"FASTMCP_FORCE_COLOR\".into(), \"1\".into())],\n            clear_env: vec![\"MCP_CLIENT\".into(), \"CLAUDE_CODE\".into(), \"NO_COLOR\".into()],\n            ..Default::default()\n        }\n    }\n}\n\n/// Run a test server and capture output\npub struct TestServerRunner {\n    config: E2ETestConfig,\n}\n\nimpl TestServerRunner {\n    pub fn new(config: E2ETestConfig) -> Self {\n        Self { config }\n    }\n    \n    /// Run test server binary and capture output\n    pub fn run_server(&self, args: &[&str]) -> TestServerResult {\n        let start = std::time::Instant::now();\n        \n        let mut cmd = Command::new(env!(\"CARGO_BIN_EXE_test_server\"));\n        cmd.args(args)\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n        \n        // Set environment variables\n        for (key, value) in &self.config.env_vars {\n            cmd.env(key, value);\n        }\n        \n        // Clear environment variables\n        for key in &self.config.clear_env {\n            cmd.env_remove(key);\n        }\n        \n        eprintln!(\"[E2E] Starting server with args: {:?}\", args);\n        eprintln!(\"[E2E] Environment: {:?}\", self.config.env_vars);\n        \n        let mut child = cmd.spawn().expect(\"Failed to spawn test server\");\n        \n        // Capture output with timeout\n        let stdout_handle = child.stdout.take().unwrap();\n        let stderr_handle = child.stderr.take().unwrap();\n        \n        let stdout_reader = BufReader::new(stdout_handle);\n        let stderr_reader = BufReader::new(stderr_handle);\n        \n        let stdout_lines: Vec<String> = stdout_reader.lines()\n            .filter_map(Result::ok)\n            .collect();\n        let stderr_lines: Vec<String> = stderr_reader.lines()\n            .filter_map(Result::ok)\n            .collect();\n        \n        let status = child.wait().expect(\"Failed to wait for server\");\n        let duration = start.elapsed();\n        \n        eprintln!(\"[E2E] Server completed in {:?} with status: {:?}\", duration, status);\n        eprintln!(\"[E2E] Stdout lines: {}\", stdout_lines.len());\n        eprintln!(\"[E2E] Stderr lines: {}\", stderr_lines.len());\n        \n        TestServerResult {\n            stdout: stdout_lines,\n            stderr: stderr_lines,\n            exit_code: status.code().unwrap_or(-1),\n            duration,\n        }\n    }\n    \n    /// Send JSON-RPC messages to running server via stdin\n    pub fn run_with_messages(&self, messages: &[&str]) -> TestServerResult {\n        let mut cmd = Command::new(env!(\"CARGO_BIN_EXE_test_server\"));\n        cmd.stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n        \n        for (key, value) in &self.config.env_vars {\n            cmd.env(key, value);\n        }\n        \n        let mut child = cmd.spawn().expect(\"Failed to spawn\");\n        \n        // Send messages to stdin\n        if let Some(stdin) = child.stdin.as_mut() {\n            for msg in messages {\n                eprintln!(\"[E2E] Sending: {}\", msg);\n                writeln!(stdin, \"{}\", msg).expect(\"Failed to write\");\n            }\n        }\n        \n        // Capture output...\n        // (similar to above)\n        todo!()\n    }\n}\n\n/// Result of running a test server\n#[derive(Debug)]\npub struct TestServerResult {\n    pub stdout: Vec<String>,\n    pub stderr: Vec<String>,\n    pub exit_code: i32,\n    pub duration: Duration,\n}\n\nimpl TestServerResult {\n    /// Check if stderr contains a string (for rich output)\n    pub fn stderr_contains(&self, needle: &str) -> bool {\n        self.stderr.iter().any(|line| line.contains(needle))\n    }\n    \n    /// Check if stdout contains a string (for JSON-RPC)\n    pub fn stdout_contains(&self, needle: &str) -> bool {\n        self.stdout.iter().any(|line| line.contains(needle))\n    }\n    \n    /// Check that stdout contains ONLY valid JSON-RPC\n    pub fn stdout_is_valid_jsonrpc(&self) -> bool {\n        self.stdout.iter().all(|line| {\n            if line.trim().is_empty() {\n                return true;\n            }\n            serde_json::from_str::<serde_json::Value>(line).is_ok()\n        })\n    }\n    \n    /// Check for ANSI escape codes\n    pub fn has_ansi_codes(&self) -> bool {\n        let combined = self.stderr.join(\"\\n\");\n        combined.contains(\"\\x1b[\") || combined.contains(\"\\033[\")\n    }\n    \n    /// Assert no ANSI in stdout (critical for agent mode)\n    pub fn assert_stdout_no_ansi(&self) {\n        let combined = self.stdout.join(\"\\n\");\n        assert!(\n            !combined.contains(\"\\x1b[\") && !combined.contains(\"\\033[\"),\n            \"stdout must not contain ANSI codes! Found in stdout:\\n{}\",\n            combined\n        );\n    }\n    \n    /// Print detailed diagnostics\n    pub fn print_diagnostics(&self) {\n        eprintln!(\"\\n=== E2E Test Result ===\");\n        eprintln!(\"Exit code: {}\", self.exit_code);\n        eprintln!(\"Duration: {:?}\", self.duration);\n        eprintln!(\"\\n--- STDOUT ({} lines) ---\", self.stdout.len());\n        for (i, line) in self.stdout.iter().enumerate() {\n            eprintln!(\"{:4}: {}\", i + 1, line);\n        }\n        eprintln!(\"\\n--- STDERR ({} lines) ---\", self.stderr.len());\n        for (i, line) in self.stderr.iter().enumerate() {\n            eprintln!(\"{:4}: {}\", i + 1, line);\n        }\n        eprintln!(\"======================\\n\");\n    }\n}\n```\n\n### Server Lifecycle Test (server_lifecycle.rs)\n\n```rust\n// tests/e2e/server_lifecycle.rs\n\nuse super::helpers::*;\n\n#[test]\nfn test_server_startup_shows_banner() {\n    let runner = TestServerRunner::new(E2ETestConfig::human_mode());\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    \n    // Should show banner on stderr\n    assert!(result.stderr_contains(\"FastMCP\"), \"Should show server name in banner\");\n    \n    // stdout should be clean (no rich output)\n    assert!(result.stdout_is_valid_jsonrpc(), \"stdout must be valid JSON-RPC only\");\n}\n\n#[test]\nfn test_server_shows_capabilities() {\n    let runner = TestServerRunner::new(E2ETestConfig::human_mode());\n    let result = runner.run_server(&[\"--show-capabilities\"]);\n    \n    result.print_diagnostics();\n    \n    // Should show registered tools/resources/prompts\n    assert!(result.stderr_contains(\"Tools\") || result.stderr_contains(\"tools\"));\n}\n\n#[test]\nfn test_server_handles_request_and_logs() {\n    let runner = TestServerRunner::new(E2ETestConfig::human_mode());\n    \n    let messages = &[\n        r#\"{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}\"#,\n        r#\"{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/list\",\"params\":{}}\"#,\n    ];\n    \n    let result = runner.run_with_messages(messages);\n    result.print_diagnostics();\n    \n    // stdout should have JSON-RPC responses\n    assert!(result.stdout_contains(\"result\"));\n    \n    // stderr should have log output\n    assert!(result.stderr_contains(\"initialize\") || result.stderr_contains(\"tools/list\"));\n}\n\n#[test]\nfn test_server_graceful_shutdown() {\n    // Test that shutdown is clean and stats are displayed\n}\n```\n\n### Agent Mode Test (agent_mode.rs)\n\n```rust\n// tests/e2e/agent_mode.rs\n\nuse super::helpers::*;\n\n#[test]\nfn test_agent_mode_no_ansi_stdout() {\n    let runner = TestServerRunner::new(E2ETestConfig::agent_mode());\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    \n    // CRITICAL: stdout must NEVER have ANSI codes\n    result.assert_stdout_no_ansi();\n    assert!(result.stdout_is_valid_jsonrpc());\n}\n\n#[test]\nfn test_agent_mode_minimal_stderr() {\n    let runner = TestServerRunner::new(E2ETestConfig::agent_mode());\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    \n    // stderr should have no ANSI in agent mode\n    assert!(!result.has_ansi_codes(), \"Agent mode should not have ANSI codes\");\n}\n\n#[test]\nfn test_mcp_client_env_triggers_agent_mode() {\n    let config = E2ETestConfig {\n        env_vars: vec![(\"MCP_CLIENT\".into(), \"claude-desktop\".into())],\n        ..Default::default()\n    };\n    \n    let runner = TestServerRunner::new(config);\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    \n    // Should be in agent mode\n    result.assert_stdout_no_ansi();\n}\n\n#[test]\nfn test_claude_code_env_triggers_agent_mode() {\n    let config = E2ETestConfig {\n        env_vars: vec![(\"CLAUDE_CODE\".into(), \"1\".into())],\n        ..Default::default()\n    };\n    \n    let runner = TestServerRunner::new(config);\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    result.assert_stdout_no_ansi();\n}\n\n#[test]\nfn test_no_color_env_disables_colors() {\n    let config = E2ETestConfig {\n        env_vars: vec![(\"NO_COLOR\".into(), \"1\".into())],\n        clear_env: vec![\"MCP_CLIENT\".into()],\n        ..Default::default()\n    };\n    \n    let runner = TestServerRunner::new(config);\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    assert!(!result.has_ansi_codes(), \"NO_COLOR should disable all ANSI\");\n}\n```\n\n### Human Mode Test (human_mode.rs)\n\n```rust\n// tests/e2e/human_mode.rs\n\nuse super::helpers::*;\n\n#[test]\nfn test_human_mode_has_rich_output() {\n    let runner = TestServerRunner::new(E2ETestConfig::human_mode());\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    \n    // stderr should have ANSI codes for rich output\n    assert!(result.has_ansi_codes(), \"Human mode should have ANSI codes\");\n    \n    // stdout should still be clean\n    result.assert_stdout_no_ansi();\n}\n\n#[test]\nfn test_force_color_enables_rich() {\n    let config = E2ETestConfig {\n        env_vars: vec![(\"FASTMCP_FORCE_COLOR\".into(), \"1\".into())],\n        ..Default::default()\n    };\n    \n    let runner = TestServerRunner::new(config);\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    assert!(result.has_ansi_codes(), \"FASTMCP_FORCE_COLOR should enable rich output\");\n}\n\n#[test]\nfn test_banner_style_compact() {\n    let config = E2ETestConfig {\n        env_vars: vec![\n            (\"FASTMCP_BANNER\".into(), \"compact\".into()),\n            (\"FASTMCP_FORCE_COLOR\".into(), \"1\".into()),\n        ],\n        ..Default::default()\n    };\n    \n    let runner = TestServerRunner::new(config);\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    // Compact banner should be shorter than full\n}\n\n#[test]\nfn test_banner_style_none() {\n    let config = E2ETestConfig {\n        env_vars: vec![(\"FASTMCP_BANNER\".into(), \"none\".into())],\n        ..Default::default()\n    };\n    \n    let runner = TestServerRunner::new(config);\n    let result = runner.run_server(&[\"--demo-mode\"]);\n    \n    result.print_diagnostics();\n    // Should not show FastMCP banner\n    assert!(!result.stderr_contains(\"FastMCP\") || result.stderr.len() < 5);\n}\n```\n\n### Error Display Test (error_display.rs)\n\n```rust\n// tests/e2e/error_display.rs\n\nuse super::helpers::*;\n\n#[test]\nfn test_error_display_in_human_mode() {\n    let runner = TestServerRunner::new(E2ETestConfig::human_mode());\n    let result = runner.run_server(&[\"--trigger-error\", \"transport\"]);\n    \n    result.print_diagnostics();\n    \n    // Should show styled error\n    assert!(result.stderr_contains(\"Error\") || result.stderr_contains(\"error\"));\n    // Should have suggestions\n    assert!(result.stderr_contains(\"Suggestion\") || result.stderr_contains(\"suggestion\"));\n}\n\n#[test]\nfn test_error_display_in_agent_mode() {\n    let runner = TestServerRunner::new(E2ETestConfig::agent_mode());\n    let result = runner.run_server(&[\"--trigger-error\", \"transport\"]);\n    \n    result.print_diagnostics();\n    \n    // Should still show error but without styling\n    assert!(result.stderr_contains(\"error\") || result.stderr_contains(\"Error\"));\n    result.assert_stdout_no_ansi();\n}\n```\n\n## Test Binary (fixtures/test_server.rs)\n\n```rust\n// tests/fixtures/test_server.rs\n// This becomes a binary that E2E tests can spawn\n\nuse fastmcp::Server;\nuse fastmcp_console::ConsoleConfig;\n\n#[tokio::main]\nasync fn main() {\n    let args: Vec<String> = std::env::args().collect();\n    \n    let config = ConsoleConfig::from_env();\n    \n    let mut server = Server::new(\"test-server\")\n        .version(\"1.0.0\")\n        .with_console_config(config)\n        .tool(dummy_tool);\n    \n    if args.contains(&\"--demo-mode\".to_string()) {\n        // Just show startup and exit\n        server.display_startup();\n        return;\n    }\n    \n    if args.contains(&\"--show-capabilities\".to_string()) {\n        server.display_capabilities();\n        return;\n    }\n    \n    if args.contains(&\"--trigger-error\".to_string()) {\n        let idx = args.iter().position(|a| a == \"--trigger-error\").unwrap();\n        let error_type = args.get(idx + 1).map(|s| s.as_str()).unwrap_or(\"generic\");\n        \n        match error_type {\n            \"transport\" => server.trigger_error(fastmcp::Error::Transport(\"test\".into())),\n            \"timeout\" => server.trigger_error(fastmcp::Error::Timeout(std::time::Duration::from_secs(30))),\n            _ => server.trigger_error(fastmcp::Error::Internal(\"test\".into())),\n        }\n        return;\n    }\n    \n    // Normal operation\n    server.run_stdio().await.unwrap();\n}\n\n#[fastmcp::tool]\nfn dummy_tool(x: i32) -> i32 {\n    x + 1\n}\n```\n\n## Running E2E Tests\n\n```bash\n# Run all E2E tests with verbose output\ncargo test -p fastmcp-console --test e2e -- --nocapture\n\n# Run specific E2E test\ncargo test -p fastmcp-console --test e2e agent_mode -- --nocapture\n\n# Run with extra logging\nRUST_LOG=debug cargo test -p fastmcp-console --test e2e -- --nocapture\n```\n\n## Acceptance Criteria\n\n- [ ] All lifecycle tests pass\n- [ ] Agent mode tests verify NO ANSI in stdout\n- [ ] Human mode tests verify rich output in stderr\n- [ ] Configuration tests verify env var handling\n- [ ] Error display tests verify suggestions appear\n- [ ] Test output is detailed enough to diagnose failures\n- [ ] Tests complete in <2 minutes total\n- [ ] Tests are not flaky (run 10x to verify)\n\n## Dependencies\n\n- Requires all implementation beads to be complete\n- Requires unit test suite (bd-1mh)\n- Requires TestConsole infrastructure (bd-2gz)","notes":"Created comprehensive E2E test suite with 35 tests covering server lifecycle, agent mode, human mode, and configuration. All tests pass.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:25:20.545752148Z","created_by":"ubuntu","updated_at":"2026-01-21T19:28:11.777596920Z","closed_at":"2026-01-21T19:28:11.777485670Z","source_repo":".","compaction_level":0,"original_size":0,"labels":["e2e","quality","rich-rust","testing"],"dependencies":[{"issue_id":"bd-294","depends_on_id":"bd-2u0","type":"blocks","created_at":"2026-01-19T21:27:02.792852042Z","created_by":"ubuntu"},{"issue_id":"bd-294","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:25:20.590877544Z","created_by":"ubuntu"}]}
{"id":"bd-2b0","title":"Spec alignment: add cancellation protocol (notifications/cancelled) + CancelledParams","description":"Implement MCP cancellation protocol per spec: add CancelledParams type, wire notifications/cancelled JSON-RPC notification, and map internal cancellation (client cancel, budget timeout, server drain) to outward notifications. Ensure all request kinds (tool/resource/prompt) use consistent cancellation signaling and outcomes, aligned with EXISTING_FASTMCP_STRUCTURE.md.","acceptance_criteria":"Protocol: CancelledParams serialized/deserialized in fastmcp-protocol with unit tests (round-trip + reason mapping). Server: emits notifications/cancelled for cancelled requests with request_id + reason, no duplicate notifications. Client: parses/handles cancellation notification without panic; internal state updates. Integration tests cover cancel path for tool/resource/prompt (simulate cancel, assert notification + outcome). E2E script runs a long request, triggers cancel, and logs request id, timestamps, and notification payloads end-to-end.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T02:27:29.227557797Z","created_by":"ubuntu","updated_at":"2026-01-25T09:59:30.611494560Z","closed_at":"2026-01-25T09:59:30.611477077Z","close_reason":"Implemented: CancelledParams + notifications/cancelled client/server handling; server tests cover notification behavior. Await-cleanup is tracked by bd-v3s.","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2d9","title":"Create comprehensive documentation and API reference","description":"# Task: Create Comprehensive Documentation\n\n## Overview\nCreate thorough documentation for the fastmcp-console crate including:\n- API reference documentation\n- Usage examples\n- Integration guide\n- Troubleshooting guide\n\n## Documentation Structure\n\n### 1. Crate-Level Documentation (lib.rs)\nAdd comprehensive module-level documentation covering:\n- Quick start guide with code examples\n- Key concepts (DisplayContext, Dual-Stream Architecture)\n- Feature flags description\n- Links to all major modules\n\n### 2. Module Documentation\nEach module should have comprehensive doc comments:\n- context module: Detection strategy, env var precedence, examples\n- theme module: Color palette, customization, examples\n- console module: Core API, printing methods, examples\n- renderers module: Each renderer with input/output examples\n- testing module: Test utilities, snapshot testing guide\n\n### 3. README.md for Crate\nCreate crates/fastmcp-console/README.md with:\n- Feature highlights (banner, logging, tables, progress, errors)\n- Quick start code example\n- Agent compatibility explanation\n- License info\n\n### 4. Examples Directory\nCreate crates/fastmcp-console/examples/:\n\n#### basic.rs\n- Console initialization\n- Banner printing\n- Logging (info, warn, error)\n- Rule printing\n\n#### tables.rs\n- Tools table rendering\n- Resources table rendering\n- Prompts table rendering\n- Custom column configuration\n\n#### custom_theme.rs\n- Theme customization\n- Color override examples\n- Applying custom themes\n\n#### agent_detection.rs\n- DisplayContext detection demo\n- Environment variable effects\n- Force mode switching\n\n## Acceptance Criteria\n\n1. Comprehensive lib.rs doc comments with examples\n2. Each public module has doc comments\n3. Each public function/struct has doc comments with examples\n4. README.md created for crate\n5. At least 4 examples in examples/ directory\n6. cargo doc generates without warnings\n7. Examples compile and run correctly\n8. Documentation covers both agent and human modes\n9. Troubleshooting section addresses common issues\n\n## Testing Documentation\n\nVerify docs compile without warnings:\n  cargo doc --no-deps -p fastmcp-console\n\nRun doc tests:\n  cargo test --doc -p fastmcp-console\n\nBuild and run examples:\n  cargo run --example basic -p fastmcp-console\n  cargo run --example tables -p fastmcp-console\n  cargo run --example custom_theme -p fastmcp-console\n  cargo run --example agent_detection -p fastmcp-console\n\n## Dependencies\n- Depends on bd-2u0 (server integration complete so all APIs are finalized)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:28:40.642514343Z","created_by":"ubuntu","updated_at":"2026-01-21T22:06:05.985643614Z","closed_at":"2026-01-21T22:06:05.985190500Z","close_reason":"All acceptance criteria verified: comprehensive lib.rs docs via README.md include, module docs for all public modules, README.md with Quick Start/Key Concepts/API Overview/Troubleshooting, 4 working examples (basic.rs, tables.rs, custom_theme.rs, agent_detection.rs), cargo doc builds without warnings, doc tests pass. Fixed 2 doc warnings in logging/formatter.rs.","source_repo":".","compaction_level":0,"original_size":0,"labels":["docs","rich-rust"],"dependencies":[{"issue_id":"bd-2d9","depends_on_id":"bd-2u0","type":"blocks","created_at":"2026-01-19T21:28:46.174696870Z","created_by":"ubuntu"},{"issue_id":"bd-2d9","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:28:40.679693952Z","created_by":"ubuntu"}]}
{"id":"bd-2fh","title":"Implement ASCII logo and gradient text rendering","description":"# Implement ASCII Logo and Gradient Text Rendering\n\n## Purpose\nCreate the visual centerpiece of FastMCP's startup experience - a stunning ASCII art logo with gradient coloring that immediately establishes a premium, professional feel when humans start the server.\n\n## Why ASCII Art?\n1. **Universal**: Works in any terminal that supports basic characters\n2. **Instant Recognition**: Creates memorable brand identity\n3. **No Images Required**: Pure text, no external dependencies\n4. **Graceful Degradation**: Falls back to simple text if needed\n\n## Logo Designs\n\n### Full Logo (for terminals >= 50 chars wide)\n```\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚                                     â”‚\nâ”‚   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â”‚\nâ”‚   â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â• â”‚\nâ”‚   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘    â”‚\nâ”‚   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â”‚\nâ”‚   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘    â”‚\nâ”‚   â•šâ•â•     â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•    â”‚\nâ”‚          â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â”‚\nâ”‚          â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â”‚\nâ”‚          â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â”‚\nâ”‚          â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â• â”‚\nâ”‚          â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â”‚\nâ”‚          â•šâ•â•     â•šâ•â• â•šâ•â•â•â•â•â•â•šâ•â•     â”‚\nâ”‚                                     â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Compact Logo (for terminals < 50 chars)\n```\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚  âš¡ FastMCP Rust         â”‚\nâ”‚  High-Performance MCP    â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Minimal Logo (fallback)\n```\nFastMCP Rust\n```\n\n## Gradient Text Implementation\n\nThe logo should be rendered with a gradient effect from the primary color (cyan) to secondary color (purple) to create visual interest.\n\n### File: crates/fastmcp-console/src/banner.rs (partial)\n\n```rust\nuse rich_rust::prelude::*;\nuse crate::theme::theme;\n\n/// ASCII art logo variants\npub const LOGO_FULL: &str = r#\"...\"#;  // Full logo above\npub const LOGO_COMPACT: &str = r#\"...\"#;  // Compact logo\npub const LOGO_MINIMAL: &str = \"FastMCP Rust\";\n\n/// Choose appropriate logo based on terminal width\npub fn choose_logo(width: usize) -> &'static str {\n    if width >= 50 {\n        LOGO_FULL\n    } else if width >= 30 {\n        LOGO_COMPACT\n    } else {\n        LOGO_MINIMAL\n    }\n}\n\n/// Render text with a vertical gradient between two colors\npub fn gradient_text(text: &str, start: &Color, end: &Color) -> String {\n    let lines: Vec<&str> = text.lines().collect();\n    let line_count = lines.len().max(1);\n    \n    let mut result = String::new();\n    \n    for (i, line) in lines.iter().enumerate() {\n        // Calculate interpolation factor (0.0 to 1.0)\n        let t = i as f64 / (line_count - 1).max(1) as f64;\n        \n        // Interpolate RGB values\n        let color = interpolate_colors(start, end, t);\n        \n        // Format with color\n        result.push_str(&format!(\"[{}]{}[/]\\n\", color.hex(), line));\n    }\n    \n    result\n}\n\n/// Linear interpolation between two colors\nfn interpolate_colors(start: &Color, end: &Color, t: f64) -> Color {\n    // Get RGB triplets\n    let start_rgb = start.get_triplet().unwrap_or(ColorTriplet::new(0, 212, 255));\n    let end_rgb = end.get_triplet().unwrap_or(ColorTriplet::new(168, 85, 247));\n    \n    // Interpolate each channel\n    let r = lerp(start_rgb.red, end_rgb.red, t);\n    let g = lerp(start_rgb.green, end_rgb.green, t);\n    let b = lerp(start_rgb.blue, end_rgb.blue, t);\n    \n    Color::from_rgb(r, g, b)\n}\n\nfn lerp(a: u8, b: u8, t: f64) -> u8 {\n    let a = a as f64;\n    let b = b as f64;\n    (a + (b - a) * t).round() as u8\n}\n\n/// Render logo with gradient (or plain fallback)\npub fn render_logo(console: &FastMcpConsole) {\n    let width = console.width();\n    let logo = choose_logo(width);\n    \n    if console.is_rich() {\n        let theme = console.theme();\n        let gradient = gradient_text(logo, &theme.primary, &theme.secondary);\n        console.print(&gradient);\n    } else {\n        // Plain fallback\n        console.print_plain(logo);\n    }\n}\n```\n\n## Visual Effect\nWhen rendered with the gradient, the logo transitions smoothly from vibrant cyan (#00d4ff) at the top to soft purple (#a855f7) at the bottom, creating a modern, polished appearance.\n\n## Acceptance Criteria\n- [ ] LOGO_FULL constant contains the full ASCII art\n- [ ] LOGO_COMPACT constant contains the compact version\n- [ ] choose_logo() selects based on terminal width\n- [ ] gradient_text() correctly interpolates colors\n- [ ] interpolate_colors() handles all Color types\n- [ ] Plain fallback works when rich is disabled\n- [ ] Logo renders correctly in both dark and light terminals\n\n## Testing\n```rust\n#[test]\nfn test_gradient_interpolation() {\n    let start = Color::from_rgb(0, 0, 0);\n    let end = Color::from_rgb(255, 255, 255);\n    let mid = interpolate_colors(&start, &end, 0.5);\n    // Should be approximately (127, 127, 127)\n}\n\n#[test]\nfn test_logo_selection() {\n    assert_eq!(choose_logo(80), LOGO_FULL);\n    assert_eq!(choose_logo(40), LOGO_COMPACT);\n    assert_eq!(choose_logo(20), LOGO_MINIMAL);\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:06:37.774808985Z","created_by":"ubuntu","updated_at":"2026-01-20T03:03:04.741259101Z","closed_at":"2026-01-20T03:03:04.741214758Z","close_reason":"Implemented ASCII logo and gradient text","source_repo":".","compaction_level":0,"original_size":0,"labels":["banner","phase-2","rich-rust","visual"],"dependencies":[{"issue_id":"bd-2fh","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:06:37.801470964Z","created_by":"ubuntu"},{"issue_id":"bd-2fh","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:09:07.370899909Z","created_by":"ubuntu"}]}
{"id":"bd-2gz","title":"Implement TestConsole for output capture in tests","description":"## Purpose and Rationale\n\nCreate a TestConsole that captures all output for assertion in tests instead of writing to stderr. This enables testing rich output without polluting test output and allows assertions on rendered content.\n\n## Background\n\nTesting code that produces rich output is challenging because:\n1. ANSI codes make string comparison difficult\n2. Output goes to stderr, polluting test output\n3. Hard to verify specific content was rendered\n\nTestConsole solves this by capturing output to an internal buffer that can be inspected.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/testing/test_console.rs\n\nuse std::sync::{Arc, Mutex};\nuse crate::console::{FastMcpConsole, ConsoleOutput};\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse strip_ansi_escapes::strip;\n\n/// A Console that captures output for testing\n#[derive(Debug, Clone)]\npub struct TestConsole {\n    inner: FastMcpConsole,\n    buffer: Arc<Mutex<TestBuffer>>,\n}\n\n#[derive(Debug, Default)]\nstruct TestBuffer {\n    lines: Vec<String>,\n    raw_lines: Vec<String>, // With ANSI codes\n}\n\nimpl TestConsole {\n    /// Create a new test console that captures output\n    pub fn new() -> Self {\n        let context = DisplayContext::new_agent(); // No rich by default\n        let buffer = Arc::new(Mutex::new(TestBuffer::default()));\n        \n        Self {\n            inner: FastMcpConsole::new_with_writer(\n                FastMcpTheme::default(),\n                context,\n                BufferWriter(buffer.clone()),\n            ),\n            buffer,\n        }\n    }\n    \n    /// Create a test console that renders rich output (for visual testing)\n    pub fn new_rich() -> Self {\n        let context = DisplayContext::new_human();\n        let buffer = Arc::new(Mutex::new(TestBuffer::default()));\n        \n        Self {\n            inner: FastMcpConsole::new_with_writer(\n                FastMcpTheme::default(),\n                context,\n                BufferWriter(buffer.clone()),\n            ),\n            buffer,\n        }\n    }\n    \n    /// Get the underlying console for passing to renderers\n    pub fn console(&self) -> &FastMcpConsole {\n        &self.inner\n    }\n    \n    /// Get all captured output (ANSI codes stripped)\n    pub fn output(&self) -> Vec<String> {\n        self.buffer.lock().unwrap().lines.clone()\n    }\n    \n    /// Get all captured output (with ANSI codes)\n    pub fn raw_output(&self) -> Vec<String> {\n        self.buffer.lock().unwrap().raw_lines.clone()\n    }\n    \n    /// Get output as a single string\n    pub fn output_string(&self) -> String {\n        self.output().join(\"\\n\")\n    }\n    \n    /// Check if output contains a string (case-insensitive)\n    pub fn contains(&self, needle: &str) -> bool {\n        let output = self.output_string().to_lowercase();\n        output.contains(&needle.to_lowercase())\n    }\n    \n    /// Check if output contains all of the given strings\n    pub fn contains_all(&self, needles: &[&str]) -> bool {\n        needles.iter().all(|n| self.contains(n))\n    }\n    \n    /// Check if output matches a regex pattern\n    #[cfg(feature = \"regex\")]\n    pub fn matches(&self, pattern: &str) -> bool {\n        let re = regex::Regex::new(pattern).expect(\"Invalid regex pattern\");\n        re.is_match(&self.output_string())\n    }\n    \n    /// Assert that output contains a string\n    pub fn assert_contains(&self, needle: &str) {\n        assert\\!(\n            self.contains(needle),\n            \"Output did not contain '{}'. Actual output:\\n{}\",\n            needle,\n            self.output_string()\n        );\n    }\n    \n    /// Assert that output does NOT contain a string\n    pub fn assert_not_contains(&self, needle: &str) {\n        assert\\!(\n            \\!self.contains(needle),\n            \"Output unexpectedly contained '{}'. Actual output:\\n{}\",\n            needle,\n            self.output_string()\n        );\n    }\n    \n    /// Assert output has specific number of lines\n    pub fn assert_line_count(&self, expected: usize) {\n        let actual = self.output().len();\n        assert_eq\\!(\n            actual, expected,\n            \"Expected {} lines but got {}. Actual output:\\n{}\",\n            expected, actual, self.output_string()\n        );\n    }\n    \n    /// Clear the buffer\n    pub fn clear(&self) {\n        let mut buf = self.buffer.lock().unwrap();\n        buf.lines.clear();\n        buf.raw_lines.clear();\n    }\n    \n    /// Print output for debugging (in tests)\n    pub fn debug_print(&self) {\n        eprintln\\!(\"=== TestConsole Output ===\");\n        for (i, line) in self.output().iter().enumerate() {\n            eprintln\\!(\"{:3}: {}\", i + 1, line);\n        }\n        eprintln\\!(\"==========================\");\n    }\n}\n\n/// Writer that captures to a buffer\nstruct BufferWriter(Arc<Mutex<TestBuffer>>);\n\nimpl std::io::Write for BufferWriter {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let s = String::from_utf8_lossy(buf);\n        let mut buffer = self.0.lock().unwrap();\n        \n        // Store raw (with ANSI)\n        buffer.raw_lines.extend(s.lines().map(String::from));\n        \n        // Store stripped (without ANSI)\n        let stripped = strip(buf);\n        let stripped_str = String::from_utf8_lossy(&stripped);\n        buffer.lines.extend(stripped_str.lines().map(String::from));\n        \n        Ok(buf.len())\n    }\n    \n    fn flush(&mut self) -> std::io::Result<()> {\n        Ok(())\n    }\n}\n```\n\n### Usage Example\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastmcp_console::testing::TestConsole;\n    \n    #[test]\n    fn test_error_rendering() {\n        let test_console = TestConsole::new();\n        let renderer = RichErrorRenderer::new(\n            FastMcpTheme::default(),\n            DisplayContext::new_agent(),\n        );\n        \n        let error = Error::Internal(\"Test error\".into());\n        renderer.render(&error, test_console.console());\n        \n        // Assert on output\n        test_console.assert_contains(\"error\");\n        test_console.assert_contains(\"Test error\");\n        test_console.assert_not_contains(\"panic\");\n    }\n    \n    #[test]\n    fn test_table_rendering() {\n        let test_console = TestConsole::new();\n        let renderer = ToolTableRenderer::new(\n            FastMcpTheme::default(),\n            DisplayContext::new_agent(),\n        );\n        \n        let tools = vec\\![\n            ToolInfo { name: \"test_tool\".into(), description: \"A test\".into(), .. }\n        ];\n        renderer.render(&tools, test_console.console());\n        \n        test_console.assert_contains(\"test_tool\");\n        test_console.assert_contains(\"A test\");\n    }\n}\n```\n\n## Implementation Steps\n\n1. Create testing/test_console.rs\n2. Implement TestBuffer for capturing output\n3. Implement BufferWriter for io::Write\n4. Add ANSI stripping using strip-ansi-escapes\n5. Implement assertion helpers\n6. Add new() and new_rich() constructors\n7. Add clear() and debug_print() utilities\n8. Write tests for TestConsole itself\n\n## Acceptance Criteria\n\n- [ ] Output is captured instead of written to stderr\n- [ ] ANSI codes are stripped for comparison\n- [ ] Raw output (with ANSI) is also available\n- [ ] contains() and assert_* helpers work correctly\n- [ ] Works with all Console operations\n- [ ] Thread-safe for parallel tests\n- [ ] clear() resets buffer correctly\n\n## Testing Strategy\n\n```rust\n#[test]\nfn test_test_console_capture() {\n    let tc = TestConsole::new();\n    tc.console().print(\"Hello, world\\!\");\n    \n    assert\\!(tc.contains(\"Hello\"));\n    assert\\!(tc.contains(\"world\"));\n    assert\\!(\\!tc.contains(\"Goodbye\"));\n}\n\n#[test]\nfn test_ansi_stripping() {\n    let tc = TestConsole::new_rich();\n    tc.console().print(\"[bold red]Error[/]\");\n    \n    // Stripped output should not have ANSI codes\n    assert\\!(tc.contains(\"Error\"));\n    assert\\!(\\!tc.output_string().contains(\"\\x1b[\"));\n    \n    // Raw output should have ANSI codes\n    assert\\!(tc.raw_output().iter().any(|l| l.contains(\"\\x1b[\")));\n}\n```\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires strip-ansi-escapes crate (add to Cargo.toml)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:18:10.809539612Z","created_by":"ubuntu","updated_at":"2026-01-20T04:19:43.445261918Z","closed_at":"2026-01-20T04:19:43.445214038Z","close_reason":"Implemented TestConsole with BufferWriter for capturing output, includes Clone/Debug impls, ANSI stripping, assertion helpers, and 11 tests","source_repo":".","compaction_level":0,"original_size":0,"labels":["capture","phase-8","rich-rust","testing"],"dependencies":[{"issue_id":"bd-2gz","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:18:10.852813608Z","created_by":"ubuntu"},{"issue_id":"bd-2gz","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:18:48.348071791Z","created_by":"ubuntu"}]}
{"id":"bd-2l8","title":"Integrate stats collection into server request handling","description":"## Purpose and Rationale\n\nWire ServerStats collection into FastMCP's request handling pipeline so metrics are automatically captured for every request. This makes the beautiful stats display actually reflect real server activity.\n\n## Background\n\nThe ServerStats struct collects metrics, but it needs to be integrated into the actual request flow. Every JSON-RPC request processed by the server should contribute to the statistics. This integration must be non-intrusive and zero-cost when stats are disabled.\n\n## Technical Specification\n\n### Integration Points\n\n#### 1. Server-Level Stats Instance\n\n```rust\n// crates/fastmcp/src/server.rs\n\npub struct Server {\n    // Existing fields...\n    \n    /// Runtime statistics collector\n    stats: Option<ServerStats>,\n}\n\nimpl Server {\n    pub fn new(name: &str) -> Self {\n        Self {\n            // ...\n            stats: Some(ServerStats::new()),\n        }\n    }\n    \n    /// Disable statistics collection\n    pub fn without_stats(mut self) -> Self {\n        self.stats = None;\n        self\n    }\n    \n    /// Get stats snapshot\n    pub fn stats(&self) -> Option<StatsSnapshot> {\n        self.stats.as_ref().map(|s| s.snapshot())\n    }\n}\n```\n\n#### 2. Request Handler Instrumentation\n\n```rust\n// In request handling path\n\nimpl Server {\n    async fn handle_request(&self, request: JsonRpcRequest) -> JsonRpcResponse {\n        let start = Instant::now();\n        let method = request.method.clone();\n        \n        // Execute the actual handler\n        let result = self.dispatch_request(request).await;\n        \n        // Record statistics\n        if let Some(stats) = &self.stats {\n            let latency = start.elapsed();\n            let success = match &result {\n                Ok(_) => true,\n                Err(_) => false,\n            };\n            stats.record_request(&method, latency, success);\n        }\n        \n        result\n    }\n}\n```\n\n#### 3. Connection Tracking\n\n```rust\n// In connection management\n\nimpl Server {\n    async fn handle_connection(&self, stream: impl AsyncRead + AsyncWrite) {\n        // Track connection open\n        if let Some(stats) = &self.stats {\n            stats.connection_opened();\n        }\n        \n        // Handle requests...\n        self.process_messages(stream).await;\n        \n        // Track connection close\n        if let Some(stats) = &self.stats {\n            stats.connection_closed();\n        }\n    }\n}\n```\n\n#### 4. Data Transfer Tracking\n\n```rust\n// In transport layer\n\nfn record_bytes_received(&self, bytes: usize) {\n    if let Some(stats) = &self.stats {\n        stats.record_bytes_received(bytes as u64);\n    }\n}\n\nfn record_bytes_sent(&self, bytes: usize) {\n    if let Some(stats) = &self.stats {\n        stats.record_bytes_sent(bytes as u64);\n    }\n}\n```\n\n### Stats Display Hook\n\nAdd a method to display stats on demand (e.g., on SIGUSR1 or via a special method):\n\n```rust\nimpl Server {\n    /// Display current statistics to stderr\n    pub fn display_stats(&self) {\n        if let Some(stats) = &self.stats {\n            let snapshot = stats.snapshot();\n            let renderer = StatsRenderer::new(\n                self.theme.clone(),\n                self.context.clone()\n            );\n            renderer.render_panel(&snapshot, &self.console);\n        }\n    }\n}\n```\n\n### Periodic Stats Logging\n\nOptionally log stats periodically:\n\n```rust\nimpl Server {\n    fn spawn_stats_logger(&self, interval: Duration) {\n        let stats = self.stats.clone();\n        let context = self.context.clone();\n        \n        asupersync::spawn(async move {\n            let mut ticker = asupersync::time::interval(interval);\n            loop {\n                ticker.tick().await;\n                if let Some(ref stats) = stats {\n                    let snap = stats.snapshot();\n                    tracing::info\\!(\n                        total_requests = snap.total_requests,\n                        success_rate = %format\\!(\"{:.1}%\", \n                            snap.successful_requests as f64 / snap.total_requests.max(1) as f64 * 100.0),\n                        avg_latency_ms = snap.avg_latency.as_millis(),\n                        \"Server statistics\"\n                    );\n                }\n            }\n        });\n    }\n}\n```\n\n## Implementation Steps\n\n1. Add ServerStats field to Server struct\n2. Initialize stats in Server::new()\n3. Add without_stats() builder method\n4. Instrument handle_request() with timing\n5. Instrument connection open/close\n6. Add bytes tracking to transport layer\n7. Add display_stats() method\n8. Add optional periodic logging\n9. Add integration tests\n\n## Acceptance Criteria\n\n- [ ] Every request contributes to statistics\n- [ ] Latency measurement is accurate\n- [ ] Connection tracking works for stdio transport\n- [ ] Byte counting is correct\n- [ ] Stats can be disabled for performance\n- [ ] display_stats() shows current metrics\n- [ ] No performance impact when stats disabled\n- [ ] Thread-safe across concurrent requests\n\n## Testing Strategy\n\n```rust\n#[tokio::test]\nasync fn test_stats_collection() {\n    let server = Server::new(\"test\");\n    \n    // Simulate some requests\n    for _ in 0..10 {\n        server.handle_request(mock_request(\"tools/list\")).await;\n    }\n    \n    let stats = server.stats().expect(\"stats enabled\");\n    assert_eq\\!(stats.total_requests, 10);\n    assert\\!(stats.avg_latency > Duration::ZERO);\n}\n```\n\n## Dependencies\n\n- Requires ServerStats (bd-6sq)\n- Requires StatsRenderer (bd-159)\n- Modifies core Server implementation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:12:26.984423483Z","created_by":"ubuntu","updated_at":"2026-01-21T17:39:57.980837190Z","closed_at":"2026-01-21T17:39:57.980769963Z","close_reason":"Completed: Integrated byte counting into server request loop - tracks bytes received on incoming requests and bytes sent on responses using ServerStats atomic counters","source_repo":".","compaction_level":0,"original_size":0,"labels":["integration","phase-4","rich-rust","stats"],"dependencies":[{"issue_id":"bd-2l8","depends_on_id":"bd-159","type":"blocks","created_at":"2026-01-19T21:12:35.142294536Z","created_by":"ubuntu"},{"issue_id":"bd-2l8","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:12:27.024829168Z","created_by":"ubuntu"},{"issue_id":"bd-2l8","depends_on_id":"bd-6sq","type":"blocks","created_at":"2026-01-19T21:12:34.946096093Z","created_by":"ubuntu"}]}
{"id":"bd-2os","title":"Protocol coverage: resources/templates/list support","description":"Add protocol support for resources/templates/list: server returns available resource templates with metadata (uriTemplate, name, description, mimeType, etc.) aligned with EXISTING_FASTMCP_STRUCTURE.md; client-side types added for request/response and server wiring for dispatch.","acceptance_criteria":"Protocol types for resources/templates/list request/response added with serde tests. Server handler lists templates from registry with stable ordering and complete metadata. Integration tests for list response content and filtering (if applicable). E2E script calls resources/templates/list and logs full response for manual inspection.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:27:40.682616837Z","created_by":"ubuntu","updated_at":"2026-01-25T11:30:51.494063093Z","closed_at":"2026-01-25T11:30:51.494045650Z","close_reason":"Completed: templates/list tests + protocol serde tests + logging","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2ov","title":"Codebase exploration + multi-pass bug hunt","description":"Randomized codebase exploration + multi-pass bug hunt: trace execution flows across core crates, identify correctness/robustness issues, fix root causes, and address UBS findings or false positives. Focus on server/router/session/protocol interactions and cancellation/budget paths.","acceptance_criteria":"Perform structured exploration across multiple modules with notes on findings. Fix any identified bugs with unit tests; add integration tests where cross-component behavior is involved. For any runtime-visible behavior, add E2E test scripts with detailed logging (timestamps, request ids, payloads). Run UBS on touched files and resolve criticals.","notes":"New fix: WsReader now rejects RSV bits (no extensions), fragmented control frames, and control frames with payload >125; added tests for RSV/control frame validation. cargo fmt/check/clippy OK (check/clippy via CARGO_TARGET_DIR=target/codex due to build lock). UBS on crates/fastmcp-transport/src/websocket.rs: 0 critical (warnings only).","status":"in_progress","priority":2,"issue_type":"task","assignee":"BrightLake","created_at":"2026-01-25T15:27:13.336593533Z","created_by":"ubuntu","updated_at":"2026-01-25T18:25:42.277493656Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2qu","title":"Create ErrorBoundary wrapper for automatic error display","description":"## Purpose and Rationale\n\nCreate an ErrorBoundary wrapper that automatically catches and beautifully displays errors throughout FastMCP. This ensures consistent error presentation without manual render calls everywhere.\n\n## Background\n\nRather than manually calling error rendering at every error site, an ErrorBoundary pattern wraps operations and automatically handles display on failure. This is similar to React's Error Boundaries but for Rust Result types.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/error/boundary.rs\n\nuse std::fmt::Display;\nuse crate::console::FastMcpConsole;\nuse crate::error::RichErrorRenderer;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\n\n/// Wraps operations and displays errors beautifully on failure\npub struct ErrorBoundary {\n    renderer: RichErrorRenderer,\n    console: FastMcpConsole,\n    exit_on_error: bool,\n    error_count: std::sync::atomic::AtomicUsize,\n}\n\nimpl ErrorBoundary {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        let console = FastMcpConsole::new_with_theme(theme.clone(), context.clone());\n        let renderer = RichErrorRenderer::new(theme, context);\n        \n        Self {\n            renderer,\n            console,\n            exit_on_error: false,\n            error_count: std::sync::atomic::AtomicUsize::new(0),\n        }\n    }\n    \n    /// Exit process on error (for CLI applications)\n    pub fn with_exit_on_error(mut self, exit: bool) -> Self {\n        self.exit_on_error = exit;\n        self\n    }\n    \n    /// Wrap a Result, displaying error if Err\n    pub fn wrap<T, E: Into<fastmcp::Error>>(&self, result: Result<T, E>) -> Option<T> {\n        match result {\n            Ok(value) => Some(value),\n            Err(e) => {\n                let error = e.into();\n                self.handle_error(&error);\n                None\n            }\n        }\n    }\n    \n    /// Wrap with custom context message\n    pub fn wrap_with_context<T, E: Into<fastmcp::Error>>(\n        &self, \n        result: Result<T, E>,\n        context: &str\n    ) -> Option<T> {\n        match result {\n            Ok(value) => Some(value),\n            Err(e) => {\n                let error = e.into();\n                self.console.print(&format!(\"[dim]Context: {}[/]\", context));\n                self.handle_error(&error);\n                None\n            }\n        }\n    }\n    \n    /// Async version for async operations\n    pub async fn wrap_async<T, E, F>(&self, future: F) -> Option<T>\n    where\n        E: Into<fastmcp::Error>,\n        F: std::future::Future<Output = Result<T, E>>,\n    {\n        match future.await {\n            Ok(value) => Some(value),\n            Err(e) => {\n                let error = e.into();\n                self.handle_error(&error);\n                None\n            }\n        }\n    }\n    \n    fn handle_error(&self, error: &fastmcp::Error) {\n        self.error_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n        self.renderer.render(error, &self.console);\n        \n        if self.exit_on_error {\n            std::process::exit(1);\n        }\n    }\n    \n    /// Get total error count\n    pub fn error_count(&self) -> usize {\n        self.error_count.load(std::sync::atomic::Ordering::Relaxed)\n    }\n    \n    /// Check if any errors have occurred\n    pub fn has_errors(&self) -> bool {\n        self.error_count() > 0\n    }\n}\n```\n\n### Convenience Macros\n\n```rust\n// crates/fastmcp-console/src/error/macros.rs\n\n/// Try an operation, display error and return None on failure\n#[macro_export]\nmacro_rules! try_display {\n    ($boundary:expr, $expr:expr) => {\n        match $boundary.wrap($expr) {\n            Some(v) => v,\n            None => return,\n        }\n    };\n    ($boundary:expr, $expr:expr, $ctx:expr) => {\n        match $boundary.wrap_with_context($expr, $ctx) {\n            Some(v) => v,\n            None => return,\n        }\n    };\n}\n\n/// Try an operation, display error and return Err on failure\n#[macro_export]\nmacro_rules! try_display_result {\n    ($boundary:expr, $expr:expr) => {\n        match $expr {\n            Ok(v) => v,\n            Err(e) => {\n                let error = e.into();\n                $boundary.handle_error(&error);\n                return Err(error);\n            }\n        }\n    };\n}\n```\n\n### Usage Example\n\n```rust\nuse fastmcp_console::error::ErrorBoundary;\nuse fastmcp_console::try_display;\n\nfn main() {\n    let boundary = ErrorBoundary::new(\n        FastMcpTheme::default(),\n        DisplayContext::detect()\n    ).with_exit_on_error(true);\n    \n    // Simple usage\n    let config = boundary.wrap(load_config());\n    \n    // With context\n    let config = boundary.wrap_with_context(\n        load_config(),\n        \"Loading server configuration\"\n    );\n    \n    // In functions\n    fn process_request(boundary: &ErrorBoundary) {\n        let data = try_display!(boundary, fetch_data());\n        let result = try_display!(boundary, process(data), \"Processing data\");\n        println!(\"Result: {:?}\", result);\n    }\n}\n```\n\n### Integration with Server\n\n```rust\nimpl Server {\n    /// Create error boundary for this server's context\n    pub fn error_boundary(&self) -> ErrorBoundary {\n        ErrorBoundary::new(\n            self.theme.clone(),\n            self.context.clone()\n        )\n    }\n}\n```\n\n## Implementation Steps\n\n1. Create error/boundary.rs\n2. Implement ErrorBoundary struct\n3. Implement wrap() and wrap_with_context()\n4. Implement wrap_async() for futures\n5. Create convenience macros\n6. Add error counting/tracking\n7. Add exit_on_error mode\n8. Document usage patterns\n\n## Acceptance Criteria\n\n- [ ] wrap() handles any Result type\n- [ ] wrap_with_context() adds context message\n- [ ] wrap_async() works with async operations\n- [ ] Macros simplify common patterns\n- [ ] Error count is tracked correctly\n- [ ] exit_on_error works for CLI apps\n- [ ] Thread-safe for concurrent use\n\n## Testing Strategy\n\n```rust\n#[test]\nfn test_error_boundary_wrap() {\n    let boundary = ErrorBoundary::new(\n        FastMcpTheme::default(),\n        DisplayContext::new_agent(), // No rich output in tests\n    );\n    \n    // Success case\n    let result: Result<i32, fastmcp::Error> = Ok(42);\n    assert_eq!(boundary.wrap(result), Some(42));\n    \n    // Error case\n    let result: Result<i32, fastmcp::Error> = Err(fastmcp::Error::Internal(\"test\".into()));\n    assert_eq!(boundary.wrap(result), None);\n    assert_eq!(boundary.error_count(), 1);\n}\n```\n\n## Dependencies\n\n- Requires RichErrorRenderer (bd-197)\n- Requires FastMcpConsole (bd-3js)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:13:41.082772805Z","created_by":"ubuntu","updated_at":"2026-01-21T09:50:30.935365787Z","closed_at":"2026-01-21T09:50:30.935294904Z","close_reason":"Implemented ErrorBoundary wrapper with wrap/wrap_with_context/wrap_result methods, error counting, exit_on_error mode, and try_display!/try_display_result! convenience macros. All 10 tests pass.","source_repo":".","compaction_level":0,"original_size":0,"labels":["errors","phase-5","rich-rust","wrapper"],"dependencies":[{"issue_id":"bd-2qu","depends_on_id":"bd-197","type":"blocks","created_at":"2026-01-19T21:13:49.818470262Z","created_by":"ubuntu"},{"issue_id":"bd-2qu","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:13:41.122205689Z","created_by":"ubuntu"},{"issue_id":"bd-2qu","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:13:50.017299608Z","created_by":"ubuntu"}]}
{"id":"bd-2r3","title":"Audit transport/documentation alignment and update docs","status":"closed","priority":2,"issue_type":"docs","created_at":"2026-01-25T02:08:14.253638523Z","created_by":"ubuntu","updated_at":"2026-01-25T02:37:16.746639036Z","closed_at":"2026-01-25T02:37:16.746279800Z","close_reason":"Updated README/plan/architecture to reflect SSE/WS transport status","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2r9","title":"Enhance logging support","description":"Improve the logging facade in fastmcp-core","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-19T01:13:23.689391058Z","created_by":"ubuntu","updated_at":"2026-01-19T01:15:20.060075538Z","closed_at":"2026-01-19T01:15:20.060034641Z","close_reason":"Logging support is comprehensive: hierarchical targets, convenience macros, is_enabled() helper, full documentation","source_repo":".","compaction_level":0,"original_size":0,"labels":["core"]}
{"id":"bd-2rx","title":"Fix clippy pedantic warnings in bench.rs and logging.rs","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-19T02:10:25.179161669Z","created_by":"ubuntu","updated_at":"2026-01-19T02:10:31.259285080Z","closed_at":"2026-01-19T02:10:31.259229195Z","close_reason":"Fixed 24+ clippy items_after_statements warnings by moving use statements to top of functions. Added #[must_use] to is_enabled() in logging.rs.","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2t6","title":"Implement URI template matching for resources","description":"Implement URI template matching for resources (e.g., file://{path}) with deterministic matching and parameter extraction per spec in EXISTING_FASTMCP_STRUCTURE.md. Provide a UriMatcher that parses templates, matches concrete URIs, returns extracted variables, and supports stable ordering when multiple templates could match.","acceptance_criteria":"Template parser handles literals, variables, and escaping; invalid templates return structured errors. Matching extracts parameters with percent-decoding where applicable and deterministic precedence when overlaps occur. Unit tests cover parser + matcher (positive/negative cases, edge cases). Integration tests verify resource lookup via templates with correct parameter bindings. E2E script queries templated resources and logs template chosen, extracted params, and response payloads.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-25T02:49:56.115616937Z","created_by":"ubuntu","updated_at":"2026-01-25T11:26:54.467639536Z","closed_at":"2026-01-25T11:26:54.467618105Z","close_reason":"Completed: URI template parsing/matching, precedence, tests incl. E2E-style logging","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2tf","title":"Add performance benchmarks","description":"Create benchmarks to validate 10-20x performance vs Python FastMCP","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-19T01:13:21.624888112Z","created_by":"ubuntu","updated_at":"2026-01-19T01:15:11.211833717Z","closed_at":"2026-01-19T01:15:11.211793291Z","close_reason":"Comprehensive benchmark suite already exists (bench.rs with server creation, JSON, protocol, codec, context, and schema benchmarks)","source_repo":".","compaction_level":0,"original_size":0,"labels":["benchmarks"]}
{"id":"bd-2u0","title":"Integrate ConsoleConfig into Server builder API","description":"## Purpose and Rationale\n\nWire ConsoleConfig into FastMCP Server so users can configure all console features through the server builder. This is the final integration point that makes everything accessible.\n\n## Background\n\nAll the rich_rust features need to be controllable through the Server API. Users should be able to configure console behavior when building their server, either by passing a config directly or through individual builder methods.\n\n## Technical Specification\n\n### Server Integration\n\n```rust\n// crates/fastmcp/src/server.rs\n\nuse fastmcp_console::{\n    ConsoleConfig, FastMcpConsole, FastMcpTheme, DisplayContext,\n    BannerStyle, TrafficVerbosity,\n};\n\nimpl Server {\n    // Existing fields plus:\n    console_config: ConsoleConfig,\n    console: Option<FastMcpConsole>,\n    \n    pub fn new(name: &str) -> Self {\n        Self {\n            name: name.to_string(),\n            // ... existing fields\n            console_config: ConsoleConfig::from_env(),\n            console: None,\n        }\n    }\n    \n    /// Set complete console configuration\n    pub fn with_console_config(mut self, config: ConsoleConfig) -> Self {\n        self.console_config = config;\n        self\n    }\n    \n    /// Set console theme\n    pub fn with_theme(mut self, theme: FastMcpTheme) -> Self {\n        self.console_config.theme = theme;\n        self\n    }\n    \n    /// Configure banner style\n    pub fn with_banner(mut self, style: BannerStyle) -> Self {\n        self.console_config = self.console_config.with_banner(style);\n        self\n    }\n    \n    /// Disable startup banner\n    pub fn without_banner(mut self) -> Self {\n        self.console_config = self.console_config.without_banner();\n        self\n    }\n    \n    /// Enable request/response traffic logging\n    pub fn with_traffic_logging(mut self, verbosity: TrafficVerbosity) -> Self {\n        self.console_config = self.console_config.with_traffic(verbosity);\n        self\n    }\n    \n    /// Enable periodic statistics display\n    pub fn with_periodic_stats(mut self, interval_secs: u64) -> Self {\n        self.console_config = self.console_config.with_periodic_stats(interval_secs);\n        self\n    }\n    \n    /// Force plain text output (no colors/styling)\n    pub fn plain_mode(mut self) -> Self {\n        self.console_config = self.console_config.plain_mode();\n        self\n    }\n    \n    /// Get the initialized console\n    fn console(&self) -> &FastMcpConsole {\n        self.console.as_ref().expect(\"Console not initialized\")\n    }\n    \n    /// Initialize console from config\n    fn init_console(&mut self) {\n        let context = self.console_config.resolve_context();\n        self.console = Some(FastMcpConsole::new_with_theme(\n            self.console_config.theme.clone(),\n            context,\n        ));\n    }\n}\n```\n\n### Updated run_stdio\n\n```rust\nimpl Server {\n    pub async fn run_stdio(mut self) -> Result<(), Error> {\n        // Initialize console\n        self.init_console();\n        \n        // Initialize rich logging\n        if let Some(level) = self.console_config.log_level {\n            self.init_rich_logging(level)?;\n        }\n        \n        // Display startup banner\n        if self.console_config.show_banner {\n            self.display_startup_banner();\n        }\n        \n        // Display capabilities summary\n        if self.console_config.show_capabilities {\n            self.display_capabilities_summary();\n        }\n        \n        // Start periodic stats if enabled\n        if self.console_config.show_stats_periodic {\n            self.spawn_stats_logger(\n                Duration::from_secs(self.console_config.stats_interval_secs)\n            );\n        }\n        \n        // ... rest of run_stdio implementation\n    }\n}\n```\n\n### Usage Examples\n\n```rust\n// Example 1: Full configuration\nuse fastmcp::Server;\nuse fastmcp_console::{ConsoleConfig, BannerStyle, TrafficVerbosity};\n\n#[tokio::main]\nasync fn main() {\n    let config = ConsoleConfig::new()\n        .with_banner(BannerStyle::Full)\n        .with_log_level(tracing::Level::DEBUG)\n        .with_traffic(TrafficVerbosity::Summary)\n        .with_periodic_stats(30);\n    \n    Server::new(\"my-mcp-server\")\n        .with_console_config(config)\n        .tool(calculate)\n        .run_stdio()\n        .await\n        .unwrap();\n}\n\n// Example 2: Builder methods\nServer::new(\"my-mcp-server\")\n    .with_banner(BannerStyle::Compact)\n    .with_traffic_logging(TrafficVerbosity::Headers)\n    .plain_mode() // For CI/testing\n    .run_stdio()\n    .await\n    .unwrap();\n\n// Example 3: Environment-driven (production)\nServer::new(\"my-mcp-server\")\n    // ConsoleConfig::from_env() is default\n    .tool(my_tool)\n    .run_stdio()\n    .await\n    .unwrap();\n```\n\n### Documentation Updates\n\nAdd to README.md:\n\n```markdown\n## Console Configuration\n\nFastMCP provides rich console output for debugging and monitoring.\n\n### Environment Variables\n\n| Variable | Description |\n|----------|-------------|\n| `FASTMCP_BANNER` | Banner style: full/compact/minimal/none |\n| `FASTMCP_LOG` | Log level: trace/debug/info/warn/error |\n| `FASTMCP_TRAFFIC` | Traffic logging: none/summary/headers/full |\n| `NO_COLOR` | Disable all colors |\n\n### Programmatic Configuration\n\n\\`\\`\\`rust\nuse fastmcp_console::{ConsoleConfig, BannerStyle};\n\nlet server = Server::new(\"demo\")\n    .with_console_config(\n        ConsoleConfig::new()\n            .with_banner(BannerStyle::Compact)\n    );\n\\`\\`\\`\n```\n\n## Implementation Steps\n\n1. Add ConsoleConfig field to Server struct\n2. Initialize console in run_stdio()\n3. Add all builder methods to Server\n4. Wire banner display to config\n5. Wire traffic logging to config\n6. Wire periodic stats to config\n7. Update examples in repo\n8. Update README with configuration docs\n\n## Acceptance Criteria\n\n- [ ] with_console_config() accepts full config\n- [ ] Individual builder methods work correctly\n- [ ] Environment variables control behavior\n- [ ] Banner respects configuration\n- [ ] Traffic logging respects verbosity setting\n- [ ] Periodic stats work when enabled\n- [ ] plain_mode() disables all styling\n- [ ] Examples compile and work\n\n## Testing Strategy\n\n```rust\n#[tokio::test]\nasync fn test_server_console_config() {\n    let config = ConsoleConfig::new()\n        .without_banner()\n        .plain_mode();\n    \n    let server = Server::new(\"test\")\n        .with_console_config(config);\n    \n    // Verify config is applied\n    assert!(!server.console_config.show_banner);\n    assert!(server.console_config.force_plain);\n}\n```\n\n## Dependencies\n\n- Requires ConsoleConfig (bd-3op)\n- Requires all renderer components to be complete\n- Requires logging integration (bd-320)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:20:00.469362163Z","created_by":"ubuntu","updated_at":"2026-01-21T18:15:34.303811546Z","closed_at":"2026-01-21T18:15:34.303768214Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"labels":["config","phase-9","rich-rust","server"],"dependencies":[{"issue_id":"bd-2u0","depends_on_id":"bd-2l8","type":"blocks","created_at":"2026-01-19T21:20:12.064199889Z","created_by":"ubuntu"},{"issue_id":"bd-2u0","depends_on_id":"bd-320","type":"blocks","created_at":"2026-01-19T21:20:11.756283774Z","created_by":"ubuntu"},{"issue_id":"bd-2u0","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:20:00.511597806Z","created_by":"ubuntu"},{"issue_id":"bd-2u0","depends_on_id":"bd-3op","type":"blocks","created_at":"2026-01-19T21:20:11.591684273Z","created_by":"ubuntu"},{"issue_id":"bd-2u0","depends_on_id":"bd-3s3","type":"blocks","created_at":"2026-01-19T21:20:11.908491555Z","created_by":"ubuntu"}]}
{"id":"bd-2ud","title":"Implement server lifecycle hooks (lifespan)","description":"Python FastMCP supports lifespan context managers for server startup/shutdown. Add lifespan support to ServerBuilder with async setup/teardown.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-25T03:24:51.331354534Z","created_by":"ubuntu","updated_at":"2026-01-25T04:24:43.147147275Z","closed_at":"2026-01-25T04:24:43.147129862Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2vm","title":"Testing: expand LabRuntime deterministic tests for server cancel/timeout","description":"Expand deterministic LabRuntime tests for server cancel/timeout paths: use asupersync LabRuntime to simulate budgets, cancellation, and timeouts without flakiness. Cover tool/resource/prompt requests under cancel + timeout + drain scenarios.","acceptance_criteria":"LabRuntime-based unit/integration tests validate cancellation and timeout outcomes deterministically. Tests assert correct notifications (if enabled) and correct Outcome mapping for cancel vs timeout. Add test utilities for controlled time progression and log capture. E2E test script runs a long request under a short budget, verifies timeout path, and logs budget checkpoints + final outcome.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:28:31.497925685Z","created_by":"ubuntu","updated_at":"2026-01-25T12:04:30.634871888Z","closed_at":"2026-01-25T12:04:30.634854055Z","close_reason":"Completed: LabRuntime cancel/budget tests + virtual time progression + log capture","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2vm","depends_on_id":"bd-2b0","type":"blocks","created_at":"2026-01-25T09:59:58.796618977Z","created_by":"ubuntu"},{"issue_id":"bd-2vm","depends_on_id":"bd-v3s","type":"blocks","created_at":"2026-01-25T10:00:01.785127391Z","created_by":"ubuntu"}]}
{"id":"bd-2w6","title":"Implement StartupBanner struct and rendering","description":"# Implement StartupBanner Struct and Rendering\n\n## Purpose\nCreate the main StartupBanner component that orchestrates the entire startup display sequence - combining the logo, server info, capabilities table, and status indicators into a cohesive, informative startup experience.\n\n## What the Banner Shows\nWhen a FastMCP server starts, humans should see:\n1. **Logo**: ASCII art with gradient (establishes brand)\n2. **Server Info Panel**: Name, version, description\n3. **Capabilities Table**: Tools, resources, prompts counts with status\n4. **Ready Status**: Confirmation that server is ready\n5. **Transport Info**: What transport is active (stdio, SSE, etc.)\n\n## Implementation\n\n### File: crates/fastmcp-console/src/banner.rs\n\n```rust\n//! Startup banner for FastMCP servers.\n//!\n//! Displays a beautiful banner when the server starts, showing\n//! server info, capabilities, and ready status.\n\nuse rich_rust::prelude::*;\nuse crate::console::FastMcpConsole;\nuse crate::theme::theme;\n\n/// Builder for the startup banner\npub struct StartupBanner {\n    /// Server name (from ServerInfo)\n    server_name: String,\n    /// Server version\n    version: String,\n    /// Optional description/instructions\n    description: Option<String>,\n    /// Number of registered tools\n    tools_count: usize,\n    /// Number of registered resources\n    resources_count: usize,\n    /// Number of registered prompts\n    prompts_count: usize,\n    /// Transport type being used\n    transport: String,\n    /// Whether to show the logo\n    show_logo: bool,\n}\n\nimpl StartupBanner {\n    /// Create a new banner with server name and version\n    pub fn new(server_name: impl Into<String>, version: impl Into<String>) -> Self {\n        Self {\n            server_name: server_name.into(),\n            version: version.into(),\n            description: None,\n            tools_count: 0,\n            resources_count: 0,\n            prompts_count: 0,\n            transport: \"stdio\".to_string(),\n            show_logo: true,\n        }\n    }\n\n    /// Set the server description\n    pub fn description(mut self, desc: impl Into<String>) -> Self {\n        self.description = Some(desc.into());\n        self\n    }\n\n    /// Set the number of tools\n    pub fn tools(mut self, count: usize) -> Self {\n        self.tools_count = count;\n        self\n    }\n\n    /// Set the number of resources\n    pub fn resources(mut self, count: usize) -> Self {\n        self.resources_count = count;\n        self\n    }\n\n    /// Set the number of prompts\n    pub fn prompts(mut self, count: usize) -> Self {\n        self.prompts_count = count;\n        self\n    }\n\n    /// Set the transport type\n    pub fn transport(mut self, transport: impl Into<String>) -> Self {\n        self.transport = transport.into();\n        self\n    }\n\n    /// Disable the logo (show only info)\n    pub fn no_logo(mut self) -> Self {\n        self.show_logo = false;\n        self\n    }\n\n    /// Render the complete banner\n    pub fn render(&self, console: &FastMcpConsole) {\n        if !console.is_rich() {\n            self.render_plain();\n            return;\n        }\n\n        let theme = theme();\n\n        // 1. Logo (if enabled)\n        if self.show_logo {\n            render_logo(console);\n            console.newline();\n        }\n\n        // 2. Server info panel\n        self.render_info_panel(console, theme);\n        console.newline();\n\n        // 3. Capabilities table\n        self.render_capabilities_table(console, theme);\n        console.newline();\n\n        // 4. Ready status\n        self.render_ready_status(console, theme);\n\n        // 5. Divider\n        console.rule(None);\n    }\n\n    fn render_info_panel(&self, console: &FastMcpConsole, theme: &FastMcpTheme) {\n        let title_line = format!(\n            \"[{}]{}[/] [{}]v{}[/]\",\n            theme.primary.hex(),\n            self.server_name,\n            theme.text_muted.hex(),\n            self.version\n        );\n\n        let mut content = title_line;\n\n        if let Some(desc) = &self.description {\n            content.push_str(&format!(\n                \"\\n[{}]{}[/]\",\n                theme.text_dim.hex(),\n                desc\n            ));\n        }\n\n        content.push_str(&format!(\n            \"\\n[{}]High-performance Model Context Protocol framework[/]\",\n            theme.text_dim.hex()\n        ));\n\n        let panel = Panel::from_text(&content)\n            .border_style(theme.border_style.clone())\n            .rounded();\n\n        console.inner.print_renderable(&panel);\n    }\n\n    fn render_capabilities_table(&self, console: &FastMcpConsole, theme: &FastMcpTheme) {\n        let mut table = Table::new()\n            .title(\"Capabilities\")\n            .title_style(theme.header_style.clone())\n            .box_style(&rich_rust::r#box::ROUNDED)\n            .border_style(theme.border_style.clone())\n            .show_header(true);\n\n        table = table\n            .add_column(Column::new(\"Type\").style(theme.label_style.clone()))\n            .add_column(Column::new(\"Count\").justify(JustifyMethod::Right))\n            .add_column(Column::new(\"Status\"));\n\n        // Tools row\n        let tools_status = if self.tools_count > 0 {\n            format!(\"[{}]âœ“ registered[/]\", theme.success.hex())\n        } else {\n            format!(\"[{}]â—‹ none[/]\", theme.text_dim.hex())\n        };\n        table.add_row_cells([\"Tools\", &self.tools_count.to_string(), &tools_status]);\n\n        // Resources row\n        let resources_status = if self.resources_count > 0 {\n            format!(\"[{}]âœ“ registered[/]\", theme.success.hex())\n        } else {\n            format!(\"[{}]â—‹ none[/]\", theme.text_dim.hex())\n        };\n        table.add_row_cells([\"Resources\", &self.resources_count.to_string(), &resources_status]);\n\n        // Prompts row\n        let prompts_status = if self.prompts_count > 0 {\n            format!(\"[{}]âœ“ registered[/]\", theme.success.hex())\n        } else {\n            format!(\"[{}]â—‹ none[/]\", theme.text_dim.hex())\n        };\n        table.add_row_cells([\"Prompts\", &self.prompts_count.to_string(), &prompts_status]);\n\n        console.inner.print_renderable(&table);\n    }\n\n    fn render_ready_status(&self, console: &FastMcpConsole, theme: &FastMcpTheme) {\n        console.print(&format!(\n            \"[{}]âœ“[/] Server ready on [{}]{}[/]\",\n            theme.success.hex(),\n            theme.accent.hex(),\n            self.transport\n        ));\n    }\n\n    /// Plain text fallback for agent/CI contexts\n    fn render_plain(&self) {\n        eprintln!(\"FastMCP Server: {} v{}\", self.server_name, self.version);\n        if let Some(desc) = &self.description {\n            eprintln!(\"  {}\", desc);\n        }\n        eprintln!(\"  Tools: {}\", self.tools_count);\n        eprintln!(\"  Resources: {}\", self.resources_count);\n        eprintln!(\"  Prompts: {}\", self.prompts_count);\n        eprintln!(\"  Transport: {}\", self.transport);\n        eprintln!(\"Server ready.\");\n    }\n}\n```\n\n## Example Output (Rich Mode)\n\n```\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚  (gradient ASCII logo here)         â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚  MyServer v1.0.0                     â”‚\nâ”‚  A helpful MCP server                â”‚\nâ”‚  High-performance MCP framework      â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€ Capabilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ Type      â”‚ Count â”‚ Status    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Tools     â”‚     5 â”‚ âœ“ reg...  â”‚\nâ”‚ Resources â”‚     2 â”‚ âœ“ reg...  â”‚\nâ”‚ Prompts   â”‚     0 â”‚ â—‹ none    â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\nâœ“ Server ready on stdio\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n\n## Example Output (Plain Mode)\n\n```\nFastMCP Server: MyServer v1.0.0\n  A helpful MCP server\n  Tools: 5\n  Resources: 2\n  Prompts: 0\n  Transport: stdio\nServer ready.\n```\n\n## Acceptance Criteria\n- [ ] StartupBanner builder pattern is ergonomic\n- [ ] All information is displayed clearly\n- [ ] Rich mode shows beautiful formatted output\n- [ ] Plain mode shows clean, readable text\n- [ ] Logo can be disabled via no_logo()\n- [ ] Works with varying terminal widths\n- [ ] Renders in under 10ms (no blocking)\n\n## Integration Point\nThis will be called from Server::run_stdio() after initialization but before entering the main message loop.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:07:14.712830061Z","created_by":"ubuntu","updated_at":"2026-01-20T03:56:32.232999772Z","closed_at":"2026-01-20T03:56:32.232937094Z","close_reason":"Implemented StartupBanner rendering","source_repo":".","compaction_level":0,"original_size":0,"labels":["banner","core","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-2w6","depends_on_id":"bd-2fh","type":"blocks","created_at":"2026-01-19T21:09:08.830428444Z","created_by":"ubuntu"},{"issue_id":"bd-2w6","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:07:14.750851458Z","created_by":"ubuntu"}]}
{"id":"bd-320","title":"Integrate rich logging into FastMCP server startup","description":"## Purpose and Rationale\n\nWire the RichTracingSubscriber into FastMCP's server startup path so that all logging throughout the server lifecycle displays with rich formatting. This is the integration point that makes all the logging work visible.\n\n## Background\n\nFastMCP servers are typically started via Server::run_stdio(). This is the ideal location to initialize the rich tracing subscriber because:\n1. It happens early enough to capture all logs\n2. We have access to configuration\n3. We can detect the display context (agent vs human)\n\n## Technical Specification\n\n### Integration Point\n\n```rust\n// crates/fastmcp/src/server.rs\n\nimpl Server {\n    pub async fn run_stdio(self) -> Result<(), Error> {\n        // NEW: Initialize rich logging early\n        self.init_rich_logging()?;\n        \n        // Existing startup banner (from Phase 2)\n        self.display_startup_banner();\n        \n        // Rest of existing implementation...\n        let (stdin, stdout) = (io::stdin(), io::stdout());\n        // ...\n    }\n    \n    fn init_rich_logging(&self) -> Result<(), Error> {\n        use fastmcp_console::logging::RichSubscriberBuilder;\n        \n        // Get configuration from server config or environment\n        let log_level = self.config.log_level.unwrap_or(LevelFilter::INFO);\n        let show_timestamps = self.config.log_timestamps.unwrap_or(true);\n        \n        // Build and initialize subscriber\n        RichSubscriberBuilder::new()\n            .with_level_filter(log_level)\n            .with_timestamps(show_timestamps)\n            .with_theme(self.console_theme.clone())\n            .init()\n            .map_err(|e| Error::Internal(format\\!(\"Failed to init logging: {}\", e)))?;\n        \n        tracing::debug\\!(\"Rich logging initialized\");\n        Ok(())\n    }\n}\n```\n\n### Configuration Options\n\nAdd logging configuration to server config:\n\n```rust\n// crates/fastmcp/src/config.rs\n\npub struct ServerConfig {\n    // Existing fields...\n    \n    /// Logging configuration\n    pub logging: LoggingConfig,\n}\n\n#[derive(Debug, Clone, Default)]\npub struct LoggingConfig {\n    /// Minimum log level (default: INFO)\n    pub level: Option<LevelFilter>,\n    \n    /// Show timestamps in logs (default: true)\n    pub timestamps: bool,\n    \n    /// Show module targets in logs (default: true)  \n    pub targets: bool,\n    \n    /// Show file:line in logs (default: false)\n    pub file_line: bool,\n    \n    /// Custom theme override\n    pub theme: Option<FastMcpTheme>,\n}\n```\n\n### Environment Variable Support\n\nHonor standard logging environment variables:\n\n```rust\nimpl LoggingConfig {\n    pub fn from_env() -> Self {\n        Self {\n            level: std::env::var(\"FASTMCP_LOG\")\n                .ok()\n                .and_then(|s| s.parse().ok()),\n            timestamps: std::env::var(\"FASTMCP_LOG_TIMESTAMPS\")\n                .map(|s| s \\!= \"0\" && s.to_lowercase() \\!= \"false\")\n                .unwrap_or(true),\n            // ... etc\n        }\n    }\n}\n```\n\n### Fallback Behavior\n\nIf rich logging init fails, fall back to standard tracing:\n\n```rust\nfn init_rich_logging(&self) -> Result<(), Error> {\n    match RichSubscriberBuilder::new()\n        .with_level_filter(log_level)\n        .init() \n    {\n        Ok(()) => Ok(()),\n        Err(e) => {\n            // Fall back to standard fmt subscriber\n            eprintln\\!(\"Warning: Rich logging unavailable: {}\", e);\n            tracing_subscriber::fmt()\n                .with_max_level(log_level)\n                .with_writer(std::io::stderr)\n                .init();\n            Ok(())\n        }\n    }\n}\n```\n\n## Implementation Steps\n\n1. Add LoggingConfig to ServerConfig struct\n2. Implement from_env() for environment variable parsing\n3. Add init_rich_logging() method to Server\n4. Call init_rich_logging() early in run_stdio()\n5. Add fallback to standard tracing on failure\n6. Update Server builder to accept logging config\n7. Add integration tests\n\n## Acceptance Criteria\n\n- [ ] Rich logging initializes before any log output\n- [ ] Configuration is respected (level, timestamps, etc)\n- [ ] Environment variables override defaults\n- [ ] Fallback works if rich logging fails\n- [ ] No interference with JSON-RPC on stdout\n- [ ] All server logs display with rich formatting\n- [ ] Integration tests verify log output\n\n## Testing Strategy\n\n```rust\n#[tokio::test]\nasync fn test_server_logging_initialization() {\n    let server = Server::new(\"test\")\n        .with_logging(LoggingConfig {\n            level: Some(LevelFilter::DEBUG),\n            ..Default::default()\n        });\n    \n    // Capture stderr and verify rich formatting\n}\n```\n\n## Dependencies\n\n- Requires RichTracingSubscriber (bd-398)\n- Requires startup banner integration (bd-3s3) to be sequenced after","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:10:36.082660534Z","created_by":"ubuntu","updated_at":"2026-01-21T18:11:00.445729869Z","closed_at":"2026-01-21T18:11:00.445685696Z","close_reason":"Completed: Integrated rich logging into server startup. Added LoggingConfig with env var support (FASTMCP_LOG, FASTMCP_LOG_TIMESTAMPS, FASTMCP_LOG_TARGETS, FASTMCP_LOG_FILE_LINE), ServerBuilder methods for logging config, and init_rich_logging() called early in run_stdio_with_cx(). 30 tests passing.","source_repo":".","compaction_level":0,"original_size":0,"labels":["integration","logging","phase-3","rich-rust"],"dependencies":[{"issue_id":"bd-320","depends_on_id":"bd-398","type":"blocks","created_at":"2026-01-19T21:10:46.384858232Z","created_by":"ubuntu"},{"issue_id":"bd-320","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:10:36.121304533Z","created_by":"ubuntu"},{"issue_id":"bd-320","depends_on_id":"bd-3s3","type":"blocks","created_at":"2026-01-19T21:10:46.544787999Z","created_by":"ubuntu"}]}
{"id":"bd-32t","title":"Add background task support (Docket/SEP-1686)","description":"Implement background task support (Docket/SEP-1686): tasks/list, tasks/get, tasks/cancel, and progress tracking for long-running operations. Surface task metadata, status transitions, and progress events per EXISTING_FASTMCP_STRUCTURE.md.","acceptance_criteria":"Protocol types for tasks/* methods added with serde tests. Server exposes task list/get/cancel endpoints wired to task manager. Progress events are emitted with stable schema and include task id + status. Integration tests cover task lifecycle (create â†’ progress â†’ complete/cancel). E2E script spins up a long-running task, polls list/get, cancels, and logs all task events with timestamps.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-25T03:26:18.890487942Z","created_by":"ubuntu","updated_at":"2026-01-25T12:41:39.453284523Z","closed_at":"2026-01-25T12:41:39.453266860Z","close_reason":"Implemented task status notifications, serde tests, integration/e2e lifecycle logging","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-32t","depends_on_id":"bd-237","type":"blocks","created_at":"2026-01-25T09:59:55.917437621Z","created_by":"ubuntu"}]}
{"id":"bd-33k","title":"Fix await_cleanup wait semantics and cancel ordering","description":"Active request cancellation waits sequentially and can delay cancelling later requests; RequestCompletion::wait_timeout returns after first wait (spurious wake risk). Update cancel_active_requests to cancel all before waiting, and make wait_timeout loop until done or timeout.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-25T10:57:06.953901712Z","created_by":"ubuntu","updated_at":"2026-01-25T11:03:10.658176321Z","closed_at":"2026-01-25T11:03:10.658158908Z","close_reason":"Fix wait_timeout spurious wake handling and cancel all requests before await_cleanup; clippy clean","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-35i","title":"Protocol coverage: resources/subscribe + resources/unsubscribe","description":"Implement resources/subscribe and resources/unsubscribe protocol: allow clients to subscribe to resource updates, track subscriptions per session, and emit notifications when resources change. Align message shapes and semantics with EXISTING_FASTMCP_STRUCTURE.md.","acceptance_criteria":"Protocol types for subscribe/unsubscribe requests and notifications added with serde tests. Server tracks subscriptions per session and cleans up on disconnect. Integration tests simulate subscription + resource update â†’ notification, plus unsubscribe stops notifications. E2E script subscribes to a resource, triggers update, and logs notifications with timestamps.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:27:46.006822611Z","created_by":"ubuntu","updated_at":"2026-01-25T11:46:53.659721796Z","closed_at":"2026-01-25T11:46:53.659704804Z","close_reason":"Completed: resource subscribe/unsubscribe notifications + tests + E2E logging","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-398","title":"Implement RichTracingSubscriber wrapper","description":"## Purpose and Rationale\n\nCreate a tracing Subscriber implementation that wraps another subscriber and adds rich formatting to stderr output. This bridges the Rust tracing ecosystem with rich_rust's beautiful output capabilities.\n\n## Background\n\nThe Rust ecosystem standardizes on the `tracing` crate for structured logging. FastMCP already uses tracing throughout. Rather than replacing the logging infrastructure, we wrap it - intercepting events and routing them through our rich formatter while preserving all existing functionality.\n\n## Technical Specification\n\n### Architecture Decision\n\nWe use a **layered approach** rather than a custom Subscriber:\n\n```rust\n// crates/fastmcp-console/src/logging/subscriber.rs\n\nuse tracing_subscriber::{Layer, Registry, fmt};\nuse tracing_subscriber::layer::SubscriberExt;\nuse std::io::{self, Write};\n\n/// A tracing Layer that formats output using rich_rust\npub struct RichLayer<W: Write = io::Stderr> {\n    formatter: RichLogFormatter,\n    writer: W,\n    console: FastMcpConsole,\n}\n\nimpl<S, W> Layer<S> for RichLayer<W>\nwhere\n    S: tracing::Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,\n    W: Write + 'static,\n{\n    fn on_event(&self, event: &tracing::Event<'_>, ctx: tracing_subscriber::layer::Context<'_, S>) {\n        // Format the event\n        let formatted = self.formatter.format_event(event);\n        \n        // Get span context for hierarchical display\n        let spans = ctx.event_scope(event)\n            .map(|scope| scope.from_root().collect::<Vec<_>>())\n            .unwrap_or_default();\n        \n        // Render to stderr using rich console\n        self.console.write_log(&formatted, &spans);\n    }\n    \n    fn on_new_span(&self, attrs: &tracing::span::Attributes<'_>, id: &tracing::span::Id, ctx: tracing_subscriber::layer::Context<'_, S>) {\n        // Optionally display span entry (configurable)\n        if self.formatter.show_span_entry {\n            // Format span entry notification\n        }\n    }\n}\n```\n\n### Subscriber Builder\n\nProvide ergonomic construction:\n\n```rust\n/// Builder for configuring the rich tracing subscriber\npub struct RichSubscriberBuilder {\n    theme: Option<FastMcpTheme>,\n    show_timestamps: bool,\n    show_targets: bool,\n    show_file_line: bool,\n    show_span_entry: bool,\n    level_filter: LevelFilter,\n    stderr_writer: bool,\n}\n\nimpl RichSubscriberBuilder {\n    pub fn new() -> Self {\n        Self {\n            theme: None,\n            show_timestamps: true,\n            show_targets: true,\n            show_file_line: false,\n            show_span_entry: false,\n            level_filter: LevelFilter::INFO,\n            stderr_writer: true,\n        }\n    }\n    \n    pub fn with_theme(mut self, theme: FastMcpTheme) -> Self {\n        self.theme = Some(theme);\n        self\n    }\n    \n    pub fn with_timestamps(mut self, show: bool) -> Self {\n        self.show_timestamps = show;\n        self\n    }\n    \n    pub fn with_level_filter(mut self, filter: LevelFilter) -> Self {\n        self.level_filter = filter;\n        self\n    }\n    \n    /// Build and install as global subscriber\n    pub fn init(self) -> Result<(), SetGlobalDefaultError> {\n        let subscriber = self.build();\n        tracing::subscriber::set_global_default(subscriber)\n    }\n    \n    /// Build without installing\n    pub fn build(self) -> impl Subscriber {\n        let context = DisplayContext::detect();\n        let theme = self.theme.unwrap_or_default();\n        let formatter = RichLogFormatter::new(theme.clone(), context.clone())\n            .with_timestamps(self.show_timestamps)\n            .with_targets(self.show_targets)\n            .with_file_line(self.show_file_line);\n            \n        let console = FastMcpConsole::new_with_theme(theme, context);\n        let rich_layer = RichLayer::new(formatter, console);\n        \n        Registry::default()\n            .with(self.level_filter)\n            .with(rich_layer)\n    }\n}\n```\n\n### Usage Example\n\n```rust\nuse fastmcp_console::logging::RichSubscriberBuilder;\n\nfn main() {\n    // Simple initialization\n    RichSubscriberBuilder::new()\n        .with_timestamps(true)\n        .with_level_filter(LevelFilter::DEBUG)\n        .init()\n        .expect(\"Failed to initialize tracing\");\n    \n    tracing::info\\!(\"Server starting\");\n    tracing::debug\\!(port = 8080, \"Binding to port\");\n}\n```\n\n### Span Visualization\n\nDisplay span context hierarchically:\n\n```\n2024-01-15 10:30:45 [INFO ] fastmcp::server Starting server\n  â””â”€ 2024-01-15 10:30:45 [DEBUG] fastmcp::transport Transport initialized\n       â””â”€ 2024-01-15 10:30:46 [INFO ] fastmcp::handler Request received method=\"tools/list\"\n```\n\n## Implementation Steps\n\n1. Create subscriber.rs in crates/fastmcp-console/src/logging/\n2. Implement RichLayer as tracing_subscriber Layer\n3. Handle on_event for log formatting\n4. Handle on_new_span/on_close for span tracking (optional)\n5. Implement RichSubscriberBuilder for ergonomic setup\n6. Add integration with DisplayContext for agent detection\n7. Ensure stderr-only output (never stdout)\n8. Add tests with test subscriber\n\n## Acceptance Criteria\n\n- [ ] RichLayer implements tracing_subscriber::Layer correctly\n- [ ] Events are formatted and written to stderr\n- [ ] Span context is preserved and optionally displayed\n- [ ] Builder provides all configuration options\n- [ ] init() correctly installs global subscriber\n- [ ] Works alongside other tracing layers\n- [ ] No output to stdout (preserves JSON-RPC stream)\n\n## Integration Notes\n\nThis subscriber should be initialized early in Server::run_stdio() BEFORE any logging occurs. The agent detection must happen at init time to avoid per-log overhead.\n\n## Dependencies\n\n- Requires RichLogFormatter (bd-nuy)\n- Requires FastMcpConsole (bd-3js)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:10:14.064328052Z","created_by":"ubuntu","updated_at":"2026-01-21T19:22:58.016518013Z","closed_at":"2026-01-21T19:22:58.016472477Z","close_reason":"Completed: Added RichLayer + RichSubscriberBuilder (tracing subscriber) using RichLogFormatter with span context and stderr-only output","source_repo":".","compaction_level":0,"original_size":0,"labels":["logging","phase-3","rich-rust","tracing"],"dependencies":[{"issue_id":"bd-398","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:10:14.099384276Z","created_by":"ubuntu"},{"issue_id":"bd-398","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:10:44.951811648Z","created_by":"ubuntu"},{"issue_id":"bd-398","depends_on_id":"bd-nuy","type":"blocks","created_at":"2026-01-19T21:10:44.787299985Z","created_by":"ubuntu"}]}
{"id":"bd-39f","title":"EPIC: Rich Rust Integration for Premium Terminal Output","description":"# Rich Rust Integration Epic\n\n## Overview\nDeeply integrate the rich_rust library into FastMCP Rust to provide stunning, professional terminal output for human observers while maintaining perfect compatibility with AI coding agents (the primary users).\n\n## The Core Problem\nFastMCP servers communicate via JSON-RPC over stdio. AI agents like Claude Code, Codex, and Cursor:\n1. Parse stdout as NDJSON - Any non-JSON text corrupts the protocol\n2. May not understand ANSI codes - Escape sequences could confuse parsing  \n3. Need deterministic output - Progress spinners and animations interfere with testing\n\n## The Solution: Dual-Stream Architecture\n- stdout: Pure JSON-RPC only, never styled, protocol messages and tool results\n- stderr: All human-readable output with full rich_rust styling (banners, logging, progress, errors)\n\nThis ensures ZERO interference with agent users while giving humans a premium visual experience.\n\n## Key Design Principles\n1. Protocol Integrity: Never corrupt the JSON-RPC stream on stdout\n2. Agent-Friendly: Auto-detect agent context and disable styling when appropriate\n3. Human-Friendly: Beautiful output when humans are watching via TTY\n4. Opt-in Styling: Use environment variables (FASTMCP_RICH, NO_COLOR) for control\n5. Graceful Fallbacks: Plain text alternatives for every rich feature\n\n## Detection Strategy\nEnvironment-based detection of agent vs human context:\n- MCP_CLIENT, CLAUDE_CODE, CODEX_CLI env vars â†’ agent mode (plain output)\n- NO_COLOR env var â†’ disable colors (standard compliance)\n- FASTMCP_RICH=1 â†’ force rich output (human debugging agent runs)\n- stderr is TTY â†’ enable rich (human watching)\n- CI=1 â†’ agent mode (automated testing)\n\n## New Crate: fastmcp-console\nCreate a dedicated crate in the workspace for all rich console functionality.\n\n## Success Criteria\n- Agent users experience zero degradation\n- Humans see beautiful, styled output on stderr\n- stdout remains pure JSON-RPC with no ANSI codes ever\n- All rich features have plain-text fallbacks\n- Environment variables provide full control\n- Comprehensive test coverage for both modes","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-19T21:03:44.316119149Z","created_by":"ubuntu","updated_at":"2026-01-21T22:19:21.206290118Z","closed_at":"2026-01-21T22:19:21.206220557Z","close_reason":"All 28 child tasks completed. Success criteria achieved: (1) Agent users have zero degradation - stdout is pure JSON-RPC, (2) Humans see beautiful styled output on stderr, (3) All rich features have plain-text fallbacks via DisplayContext, (4) Environment variables (FASTMCP_RICH, NO_COLOR, FASTMCP_PLAIN, etc.) provide full control, (5) Comprehensive test coverage in tests/integration.rs and tests/e2e/. The fastmcp-console crate is complete with banner, logging, tables, stats, error handling, and detection modules.","source_repo":".","compaction_level":0,"original_size":0,"labels":["console","integration","rich-rust"]}
{"id":"bd-39m","title":"Add authentication provider system","description":"Design and implement a Rust authentication provider system (AuthProvider trait) for MCP servers: token verification, optional JWT validation, and pluggable providers. Ensure explicit capability usage and avoid hidden globals; align with EXISTING_FASTMCP_STRUCTURE.md while keeping minimal dependencies.","acceptance_criteria":"AuthProvider trait + core types defined; supports token verification and optional JWT-based provider behind feature flag if needed. Server integrates auth checks before handler dispatch with clear error mapping. Unit tests cover token parsing, allow/deny decisions, and error mapping. Integration tests validate protected tool/resource access. E2E script attempts authorized and unauthorized requests, logging auth decisions and error payloads.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-25T03:25:22.371805257Z","created_by":"ubuntu","updated_at":"2026-01-25T12:28:34.747466163Z","closed_at":"2026-01-25T12:28:34.747448710Z","close_reason":"Implemented token auth provider, static/JWT verifier, tests + e2e logging","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-3ah","title":"Integrate SSE transport into server","description":"SSE transport module exists (crates/fastmcp-transport/src/sse.rs, ~700 lines) but is not wired into the server. Need to add run_sse() method to Server and proper HTTP server integration.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-25T02:50:47.746113474Z","created_by":"ubuntu","updated_at":"2026-01-25T04:08:40.077568723Z","closed_at":"2026-01-25T04:08:40.077478363Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-3c7","title":"Fix FastMcpConsole::with_writer color disable bug","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-25T05:05:45.384294486Z","created_by":"ubuntu","updated_at":"2026-01-25T05:05:48.834957881Z","closed_at":"2026-01-25T05:05:48.834940519Z","close_reason":"Fixed with_writer builder no_color gating","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-3dc","title":"Implement proxy/composition for multi-server scenarios","description":"Python has create_proxy() to proxy tool/resource/prompt calls to another MCP server. Enables server composition and aggregation patterns.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-01-25T03:25:56.911244526Z","created_by":"ubuntu","updated_at":"2026-01-25T09:53:33.325682661Z","closed_at":"2026-01-25T09:53:33.325654939Z","close_reason":"Implemented proxy/composition scaffolding + tests; fmt/check/clippy pass","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-3ey","title":"Create unified HandlerRegistryRenderer for complete capability display","description":"## Purpose and Rationale\n\nCreate a unified renderer that displays all server capabilities (tools, resources, prompts) in a comprehensive, well-organized format. This provides a single-call way to show everything a server exposes.\n\n## Background\n\nWhile individual renderers are useful, operators often want to see the complete picture of what a server exposes. The HandlerRegistryRenderer combines tools, resources, and prompts into a cohesive display with proper sections and summaries.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/handlers/registry.rs\n\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse crate::handlers::{ToolTableRenderer, ResourceTableRenderer, PromptTableRenderer};\nuse fastmcp::server::ServerCapabilities;\nuse rich_rust::{Panel, Rule, Table, Column};\n\n/// Unified renderer for complete server capabilities\npub struct HandlerRegistryRenderer {\n    tool_renderer: ToolTableRenderer,\n    resource_renderer: ResourceTableRenderer,\n    prompt_renderer: PromptTableRenderer,\n    theme: FastMcpTheme,\n    context: DisplayContext,\n}\n\nimpl HandlerRegistryRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            tool_renderer: ToolTableRenderer::new(theme.clone(), context.clone()),\n            resource_renderer: ResourceTableRenderer::new(theme.clone(), context.clone()),\n            prompt_renderer: PromptTableRenderer::new(theme.clone(), context.clone()),\n            theme,\n            context,\n        }\n    }\n    \n    /// Render complete server capabilities\n    pub fn render(&self, capabilities: &ServerCapabilities, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(capabilities, console);\n            return;\n        }\n        \n        // Header\n        self.render_summary_header(capabilities, console);\n        \n        // Tools section\n        if !capabilities.tools.is_empty() {\n            console.print(\"\");\n            self.tool_renderer.render(&capabilities.tools, console);\n        }\n        \n        // Resources section\n        if !capabilities.resources.is_empty() {\n            console.print(\"\");\n            self.resource_renderer.render(&capabilities.resources, console);\n        }\n        \n        // Prompts section\n        if !capabilities.prompts.is_empty() {\n            console.print(\"\");\n            self.prompt_renderer.render(&capabilities.prompts, console);\n        }\n        \n        // Footer\n        self.render_footer(capabilities, console);\n    }\n    \n    /// Render a compact summary panel\n    pub fn render_summary(&self, capabilities: &ServerCapabilities, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_summary_plain(capabilities, console);\n            return;\n        }\n        \n        let mut table = Table::new()\n            .title(\"Server Capabilities\")\n            .with_column(Column::new(\"Type\"))\n            .with_column(Column::new(\"Count\").justify(rich_rust::JustifyMethod::Right))\n            .with_column(Column::new(\"Status\"));\n        \n        // Tools\n        let tools_status = if capabilities.tools.is_empty() { \n            \"[dim]none[/]\" \n        } else { \n            \"[green]available[/]\" \n        };\n        table.add_row_cells([\"ðŸ“¦ Tools\", &capabilities.tools.len().to_string(), tools_status]);\n        \n        // Resources\n        let resources_status = if capabilities.resources.is_empty() { \n            \"[dim]none[/]\" \n        } else { \n            \"[green]available[/]\" \n        };\n        table.add_row_cells([\"ðŸ“„ Resources\", &capabilities.resources.len().to_string(), resources_status]);\n        \n        // Prompts\n        let prompts_status = if capabilities.prompts.is_empty() { \n            \"[dim]none[/]\" \n        } else { \n            \"[green]available[/]\" \n        };\n        table.add_row_cells([\"ðŸ’¬ Prompts\", &capabilities.prompts.len().to_string(), prompts_status]);\n        \n        console.print_renderable(&table);\n    }\n    \n    fn render_summary_header(&self, capabilities: &ServerCapabilities, console: &FastMcpConsole) {\n        let total = capabilities.tools.len() + capabilities.resources.len() + capabilities.prompts.len();\n        \n        let rule = Rule::with_title(format!(\"ðŸš€ Server Capabilities ({} total)\", total))\n            .style(self.theme.primary_style());\n        console.print_renderable(&rule);\n    }\n    \n    fn render_footer(&self, capabilities: &ServerCapabilities, console: &FastMcpConsole) {\n        let tools = capabilities.tools.len();\n        let resources = capabilities.resources.len();\n        let prompts = capabilities.prompts.len();\n        \n        console.print(\"\");\n        console.print(&format!(\n            \"[dim]Summary: {} tool{}, {} resource{}, {} prompt{}[/]\",\n            tools, if tools == 1 { \"\" } else { \"s\" },\n            resources, if resources == 1 { \"\" } else { \"s\" },\n            prompts, if prompts == 1 { \"\" } else { \"s\" }\n        ));\n    }\n    \n    fn render_plain(&self, capabilities: &ServerCapabilities, console: &FastMcpConsole) {\n        let total = capabilities.tools.len() + capabilities.resources.len() + capabilities.prompts.len();\n        console.print(&format!(\"=== Server Capabilities ({} total) ===\", total));\n        \n        if !capabilities.tools.is_empty() {\n            self.tool_renderer.render(&capabilities.tools, console);\n        }\n        if !capabilities.resources.is_empty() {\n            self.resource_renderer.render(&capabilities.resources, console);\n        }\n        if !capabilities.prompts.is_empty() {\n            self.prompt_renderer.render(&capabilities.prompts, console);\n        }\n    }\n    \n    fn render_summary_plain(&self, capabilities: &ServerCapabilities, console: &FastMcpConsole) {\n        console.print(\"Server Capabilities:\");\n        console.print(&format!(\"  Tools: {}\", capabilities.tools.len()));\n        console.print(&format!(\"  Resources: {}\", capabilities.resources.len()));\n        console.print(&format!(\"  Prompts: {}\", capabilities.prompts.len()));\n    }\n}\n```\n\n### Integration with Server\n\n```rust\nimpl Server {\n    /// Display all registered handlers\n    pub fn display_capabilities(&self) {\n        let renderer = HandlerRegistryRenderer::new(\n            self.theme.clone(),\n            self.context.clone()\n        );\n        \n        let capabilities = self.capabilities();\n        renderer.render(&capabilities, &self.console);\n    }\n    \n    /// Display compact summary\n    pub fn display_capabilities_summary(&self) {\n        let renderer = HandlerRegistryRenderer::new(\n            self.theme.clone(),\n            self.context.clone()\n        );\n        \n        let capabilities = self.capabilities();\n        renderer.render_summary(&capabilities, &self.console);\n    }\n}\n```\n\n### Visual Example\n\n```\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸš€ Server Capabilities (8 total) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ“¦ Registered Tools (5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Name              â”‚ Description                      â”‚ Parameters â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ calculate         â”‚ Perform mathematical calculationsâ”‚ 2 required â”‚\nâ”‚ ...               â”‚ ...                              â”‚ ...        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ“„ Registered Resources (2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ URI                    â”‚ Description                 â”‚   Type   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ file://{path}          â”‚ Read file contents          â”‚ Template â”‚\nâ”‚ ...                    â”‚ ...                         â”‚ ...      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ’¬ Registered Prompts (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Name              â”‚ Description                       â”‚ Argumentsâ”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ code_review       â”‚ Generate a code review for...     â”‚ 2 req    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nSummary: 5 tools, 2 resources, 1 prompt\n```\n\n## Implementation Steps\n\n1. Create handlers/registry.rs\n2. Implement render() for full capability display\n3. Implement render_summary() for compact view\n4. Add section headers and footers\n5. Integrate all three sub-renderers\n6. Add Server::display_capabilities() method\n7. Implement plain-text fallback\n8. Test with various capability combinations\n\n## Acceptance Criteria\n\n- [ ] Full render shows all capability types\n- [ ] Summary provides quick overview\n- [ ] Empty sections are hidden gracefully\n- [ ] Section ordering is consistent\n- [ ] Totals are calculated correctly\n- [ ] Plain-text fallback works\n- [ ] Integrates with Server struct\n\n## Dependencies\n\n- Requires ToolTableRenderer (bd-5gw)\n- Requires ResourceTableRenderer (bd-j5u)\n- Requires PromptTableRenderer (bd-y14)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:15:50.775505807Z","created_by":"ubuntu","updated_at":"2026-01-21T10:54:09.788247182Z","closed_at":"2026-01-21T10:54:09.788200324Z","close_reason":"Implemented HandlerRegistryRenderer in handlers.rs with: ServerCapabilities struct to hold tools/resources/prompts, render() for full capability display with headers and footers, render_summary() for compact overview, render_if_present() for conditional rendering, plain-text fallbacks, and 8 comprehensive tests. Properly delegates to ToolTableRenderer, ResourceTableRenderer, and PromptTableRenderer.","source_repo":".","compaction_level":0,"original_size":0,"labels":["handlers","phase-6","rich-rust","unified"],"dependencies":[{"issue_id":"bd-3ey","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:15:50.816969595Z","created_by":"ubuntu"},{"issue_id":"bd-3ey","depends_on_id":"bd-5gw","type":"blocks","created_at":"2026-01-19T21:16:05.369713435Z","created_by":"ubuntu"},{"issue_id":"bd-3ey","depends_on_id":"bd-j5u","type":"blocks","created_at":"2026-01-19T21:16:05.521733078Z","created_by":"ubuntu"},{"issue_id":"bd-3ey","depends_on_id":"bd-y14","type":"blocks","created_at":"2026-01-19T21:16:05.640690110Z","created_by":"ubuntu"}]}
{"id":"bd-3h3","title":"Create fastmcp-console crate skeleton","description":"# Create fastmcp-console Crate Skeleton\n\n## Purpose\nThis is the FOUNDATIONAL task for the entire rich_rust integration. Every other task in this epic depends on this crate existing. The fastmcp-console crate will house all rich terminal output functionality, keeping it cleanly separated from protocol concerns.\n\n## Why a Separate Crate?\n1. **Separation of Concerns**: Console output is orthogonal to MCP protocol\n2. **Optional Dependency**: Projects can use FastMCP without rich output\n3. **Testing Isolation**: Rich output can be tested independently\n4. **Feature Flags**: Can gate rich_rust dependency behind feature flags\n5. **Build Time**: Optional compilation of rich features\n\n## What to Create\n\n### Directory Structure\n```\ncrates/fastmcp-console/\nâ”œâ”€â”€ Cargo.toml\nâ””â”€â”€ src/\n    â””â”€â”€ lib.rs           # Module root with re-exports\n```\n\n### Cargo.toml Contents\n```toml\n[package]\nname = \"fastmcp-console\"\nversion = \"0.1.0\"\nedition = \"2024\"\ndescription = \"Rich console output for FastMCP servers\"\nlicense = \"MIT\"\nrepository = \"https://github.com/Dicklesworthstone/fastmcp_rust\"\n\n[dependencies]\nrich_rust = { path = \"/dp/rich_rust\" }  # Or git dependency\nlog = \"0.4\"\n\n[features]\ndefault = []\nfull = [\"rich_rust/full\"]  # Include syntax, markdown, json features\nsyntax = [\"rich_rust/syntax\"]\nmarkdown = [\"rich_rust/markdown\"]\njson = [\"rich_rust/json\"]\n\n[lints]\nworkspace = true\n```\n\n### lib.rs Initial Contents\n```rust\n#![forbid(unsafe_code)]\n#![doc = include_str!(\"../README.md\")]\n\n// Modules will be added as they are implemented:\n// pub mod detection;  // Agent vs human detection\n// pub mod theme;      // FastMCP color theme\n// pub mod console;    // Console wrapper\n// pub mod banner;     // Startup banner\n// pub mod status;     // Request logging\n// pub mod progress;   // Progress indicators\n// pub mod diagnostics;// Error formatting\n// pub mod logging;    // Rich log formatter\n// pub mod tables;     // Info tables\n// pub mod testing;    // Test utilities\n\n// Re-export rich_rust for convenience\npub use rich_rust;\n```\n\n### Update Workspace Cargo.toml\nAdd to the workspace members:\n```toml\n[workspace]\nmembers = [\n    # ... existing crates ...\n    \"crates/fastmcp-console\",\n]\n```\n\n## Acceptance Criteria\n- [ ] Crate compiles with `cargo check -p fastmcp-console`\n- [ ] Crate is listed in workspace members\n- [ ] rich_rust dependency resolves correctly\n- [ ] Feature flags are properly configured\n- [ ] `#![forbid(unsafe_code)]` is set\n- [ ] Basic lib.rs structure is in place\n\n## Technical Notes\n- Use path dependency during development, switch to git/crates.io for release\n- The crate should have minimal dependencies beyond rich_rust\n- All modules will be added incrementally as subsequent tasks complete\n\n## Blockers\nNone - this is the root foundation task.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:04:03.855397100Z","created_by":"ubuntu","updated_at":"2026-01-20T02:59:19.489202427Z","closed_at":"2026-01-20T02:59:19.489138136Z","close_reason":"Created fastmcp-console crate with all modules","source_repo":".","compaction_level":0,"original_size":0,"labels":["foundation","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-3h3","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:04:03.885841711Z","created_by":"ubuntu"}]}
{"id":"bd-3js","title":"Implement FastMcpConsole wrapper","description":"# Implement FastMcpConsole Wrapper\n\n## Purpose\nThis is the CENTRAL COMPONENT that all other rich output flows through. FastMcpConsole wraps rich_rust's Console, adding:\n1. Automatic agent detection (enable/disable styling)\n2. Always writes to stderr (never stdout)\n3. Plain-text fallbacks when rich is disabled\n4. Integration with FastMCP's theme system\n5. Global accessor for convenient use throughout codebase\n\n## Critical Design Constraint: stderr Only\n**FastMcpConsole MUST write to stderr, NEVER stdout.**\n\nWhy? Because stdout is reserved for JSON-RPC protocol messages:\n- Agents parse stdout as NDJSON\n- ANY non-JSON text on stdout corrupts the protocol\n- All human-readable output goes to stderr\n- This is the fundamental architectural decision enabling agent compatibility\n\n## Implementation\n\n### File: crates/fastmcp-console/src/console.rs\n\n```rust\n//\\! FastMCP Console wrapper for rich output to stderr.\n//\\!\n//\\! This module provides the central Console abstraction that automatically\n//\\! handles agent detection, theming, and fallback to plain text.\n\nuse rich_rust::prelude::*;\nuse std::io::{self, Write};\nuse std::sync::OnceLock;\n\nuse crate::detection::should_enable_rich;\nuse crate::theme::{theme, FastMcpTheme};\n\n/// FastMCP console for rich output to stderr\npub struct FastMcpConsole {\n    inner: Console,\n    enabled: bool,\n}\n\nimpl FastMcpConsole {\n    /// Create with automatic detection\n    pub fn new() -> Self {\n        let enabled = should_enable_rich();\n        Self::with_enabled(enabled)\n    }\n\n    /// Create with explicit enable/disable\n    pub fn with_enabled(enabled: bool) -> Self {\n        let inner = if enabled {\n            Console::builder()\n                .file(Box::new(io::stderr()))\n                .force_terminal(true)\n                .markup(true)\n                .emoji(true)\n                .build()\n        } else {\n            Console::builder()\n                .file(Box::new(io::stderr()))\n                .color_system(None)  // Disable colors entirely\n                .markup(false)\n                .emoji(false)\n                .build()\n        };\n\n        Self { inner, enabled }\n    }\n\n    /// Create with custom writer (for testing)\n    pub fn with_writer<W: Write + Send + 'static>(writer: W, enabled: bool) -> Self {\n        let inner = Console::builder()\n            .file(Box::new(writer))\n            .color_system(if enabled { None } else { None })\n            .markup(enabled)\n            .emoji(enabled)\n            .build();\n\n        Self { inner, enabled }\n    }\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // State Queries\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n    /// Check if rich output is enabled\n    pub fn is_rich(&self) -> bool {\n        self.enabled\n    }\n\n    /// Get the theme\n    pub fn theme(&self) -> &'static FastMcpTheme {\n        theme()\n    }\n\n    /// Get terminal width (or default 80)\n    pub fn width(&self) -> usize {\n        self.inner.width().unwrap_or(80)\n    }\n\n    /// Get terminal height (or default 24)\n    pub fn height(&self) -> usize {\n        self.inner.height().unwrap_or(24)\n    }\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // Output Methods\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n    /// Print content with markup parsing (if enabled)\n    pub fn print(&self, content: &str) {\n        if self.enabled {\n            self.inner.print(content);\n        } else {\n            eprintln\\!(\"{}\", strip_markup(content));\n        }\n    }\n\n    /// Print plain text (no markup processing ever)\n    pub fn print_plain(&self, text: &str) {\n        eprintln\\!(\"{}\", text);\n    }\n\n    /// Print a renderable (table, panel, etc.)\n    pub fn render<'a>(&self, renderable: impl Fn() -> Vec<Segment<'a>>) {\n        if self.enabled {\n            let segments = renderable();\n            for segment in segments {\n                self.inner.print_segment(&segment);\n            }\n        }\n        // Plain fallback: caller should provide alternative\n    }\n\n    /// Print a renderable with plain-text fallback\n    pub fn render_or<'a, F>(&self, renderable: F, plain_fallback: &str)\n    where\n        F: FnOnce(&Console) -> (),\n    {\n        if self.enabled {\n            renderable(&self.inner);\n        } else {\n            eprintln\\!(\"{}\", plain_fallback);\n        }\n    }\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // Convenience Methods\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n    /// Print a horizontal rule\n    pub fn rule(&self, title: Option<&str>) {\n        if self.enabled {\n            let rule = match title {\n                Some(t) => Rule::with_title(t).style(self.theme().border_style.clone()),\n                None => Rule::new().style(self.theme().border_style.clone()),\n            };\n            self.inner.print_renderable(&rule);\n        } else {\n            match title {\n                Some(t) => eprintln\\!(\"--- {} ---\", t),\n                None => eprintln\\!(\"---\"),\n            }\n        }\n    }\n\n    /// Print a blank line\n    pub fn newline(&self) {\n        eprintln\\!();\n    }\n\n    /// Print styled text with a specific style\n    pub fn print_styled(&self, text: &str, style: &Style) {\n        if self.enabled {\n            self.inner.print_styled(text, style.clone());\n        } else {\n            eprintln\\!(\"{}\", text);\n        }\n    }\n\n    /// Print a table (with plain fallback)\n    pub fn print_table(&self, table: &Table, plain_fallback: &str) {\n        if self.enabled {\n            self.inner.print_renderable(table);\n        } else {\n            eprintln\\!(\"{}\", plain_fallback);\n        }\n    }\n\n    /// Print a panel (with plain fallback)\n    pub fn print_panel(&self, panel: &Panel, plain_fallback: &str) {\n        if self.enabled {\n            self.inner.print_renderable(panel);\n        } else {\n            eprintln\\!(\"{}\", plain_fallback);\n        }\n    }\n}\n\nimpl Default for FastMcpConsole {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Global Console Accessor\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nstatic CONSOLE: OnceLock<FastMcpConsole> = OnceLock::new();\n\n/// Get the global FastMCP console instance\npub fn console() -> &'static FastMcpConsole {\n    CONSOLE.get_or_init(FastMcpConsole::new)\n}\n\n/// Initialize the global console with specific settings\n/// Must be called before any output; returns error if already initialized\npub fn init_console(enabled: bool) -> Result<(), &'static str> {\n    CONSOLE.set(FastMcpConsole::with_enabled(enabled))\n        .map_err(|_| \"Console already initialized\")\n}\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Helpers\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/// Strip markup tags from text (for plain output)\nfn strip_markup(text: &str) -> String {\n    // Simple regex to remove [tag] and [/tag] patterns\n    // In practice, use rich_rust's internal function if exposed\n    let re = regex::Regex::new(r\"\\[/?[^\\]]*\\]\").unwrap();\n    re.replace_all(text, \"\").to_string()\n}\n```\n\n## Usage Examples\n\n### Basic Usage\n```rust\nuse fastmcp_console::console;\n\n// Automatically detects agent context\nlet c = console();\n\n// Print with markup (styled if rich enabled, plain otherwise)\nc.print(\"[bold green]Success\\![/] Operation completed.\");\n\n// Print plain (never styled)\nc.print_plain(\"Debug: raw data here\");\n\n// Horizontal rule\nc.rule(Some(\"Configuration\"));\n\n// Check if rich is enabled\nif c.is_rich() {\n    // Do fancy rendering\n} else {\n    // Use simple fallback\n}\n```\n\n### With Explicit Control\n```rust\n// Force rich output (for debugging)\nlet c = FastMcpConsole::with_enabled(true);\n\n// Force plain output (for testing)\nlet c = FastMcpConsole::with_enabled(false);\n```\n\n## Acceptance Criteria\n- [ ] Console ALWAYS writes to stderr, NEVER stdout\n- [ ] is_rich() correctly reflects detection results\n- [ ] print() strips markup when rich is disabled\n- [ ] All renderables have plain-text fallback paths\n- [ ] console() returns a static reference (no allocation per call)\n- [ ] init_console() allows early initialization with explicit settings\n- [ ] Works correctly with custom writers (for testing)\n\n## Integration Points\nThis console will be used by:\n- Banner (startup display)\n- Logging (RichLogger)\n- Status display (request/response)\n- Error formatting\n- Progress indicators\n- All other rich output\n\n## Testing Strategy\n```rust\n#[test]\nfn test_plain_mode_strips_markup() {\n    let console = FastMcpConsole::with_enabled(false);\n    // Capture stderr and verify no ANSI codes\n}\n\n#[test]\nfn test_rich_mode_preserves_markup() {\n    let console = FastMcpConsole::with_enabled(true);\n    // Capture output and verify ANSI codes present\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:05:45.787947959Z","created_by":"ubuntu","updated_at":"2026-01-20T03:00:45.364617722Z","closed_at":"2026-01-20T03:00:45.364533403Z","close_reason":"Implemented enhanced FastMcpConsole wrapper","source_repo":".","compaction_level":0,"original_size":0,"labels":["console","foundation","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-3js","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:05:59.178007432Z","created_by":"ubuntu"},{"issue_id":"bd-3js","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:05:45.825490825Z","created_by":"ubuntu"},{"issue_id":"bd-3js","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:05:58.384997421Z","created_by":"ubuntu"}]}
{"id":"bd-3lr","title":"Combinators: add parallel helper APIs (join/race/quorum) aligned with spec","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T02:28:26.201488230Z","created_by":"ubuntu","updated_at":"2026-01-25T07:03:08.887791335Z","closed_at":"2026-01-25T07:03:08.887461825Z","close_reason":"Implemented combinator module with join_all, race, quorum, first_ok functions. Phase 0 sequential implementations, compiles successfully.","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-3op","title":"Implement ConsoleConfig for centralized configuration","description":"## Purpose and Rationale\n\nCreate a comprehensive configuration struct that controls all aspects of rich console output. This provides a single point of configuration that can be set programmatically or via environment variables.\n\n## Background\n\nWith many configurable aspects (themes, verbosity, features), users need a clean way to control behavior. ConsoleConfig centralizes all settings and provides sensible defaults, environment variable overrides, and builder-style configuration.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/config.rs\n\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse std::env;\n\n/// Comprehensive configuration for FastMCP console output\n#[derive(Debug, Clone)]\npub struct ConsoleConfig {\n    // Display mode\n    pub context: Option<DisplayContext>,\n    pub force_color: Option<bool>,\n    pub force_plain: bool,\n    \n    // Theme\n    pub theme: FastMcpTheme,\n    pub custom_colors: Option<CustomColors>,\n    \n    // Startup\n    pub show_banner: bool,\n    pub show_capabilities: bool,\n    pub banner_style: BannerStyle,\n    \n    // Logging\n    pub log_level: Option<tracing::Level>,\n    pub log_timestamps: bool,\n    pub log_targets: bool,\n    pub log_file_line: bool,\n    \n    // Runtime\n    pub show_stats_periodic: bool,\n    pub stats_interval_secs: u64,\n    pub show_request_traffic: bool,\n    pub traffic_verbosity: TrafficVerbosity,\n    \n    // Errors\n    pub show_suggestions: bool,\n    pub show_error_codes: bool,\n    pub show_backtrace: bool,\n    \n    // Output limits\n    pub max_table_rows: usize,\n    pub max_json_depth: usize,\n    pub truncate_at: usize,\n}\n\n#[derive(Debug, Clone, Copy, Default)]\npub enum BannerStyle {\n    #[default]\n    Full,\n    Compact,\n    Minimal,\n    None,\n}\n\n#[derive(Debug, Clone, Copy, Default)]\npub enum TrafficVerbosity {\n    #[default]\n    None,\n    Summary,\n    Headers,\n    Full,\n}\n\n#[derive(Debug, Clone)]\npub struct CustomColors {\n    pub primary: Option<String>,\n    pub secondary: Option<String>,\n    pub success: Option<String>,\n    pub warning: Option<String>,\n    pub error: Option<String>,\n}\n\nimpl Default for ConsoleConfig {\n    fn default() -> Self {\n        Self {\n            context: None, // Auto-detect\n            force_color: None,\n            force_plain: false,\n            theme: FastMcpTheme::default(),\n            custom_colors: None,\n            show_banner: true,\n            show_capabilities: true,\n            banner_style: BannerStyle::Full,\n            log_level: None,\n            log_timestamps: true,\n            log_targets: true,\n            log_file_line: false,\n            show_stats_periodic: false,\n            stats_interval_secs: 60,\n            show_request_traffic: false,\n            traffic_verbosity: TrafficVerbosity::None,\n            show_suggestions: true,\n            show_error_codes: true,\n            show_backtrace: false,\n            max_table_rows: 100,\n            max_json_depth: 5,\n            truncate_at: 200,\n        }\n    }\n}\n\nimpl ConsoleConfig {\n    /// Create config with defaults\n    pub fn new() -> Self {\n        Self::default()\n    }\n    \n    /// Create config from environment variables\n    pub fn from_env() -> Self {\n        let mut config = Self::default();\n        \n        // Display mode\n        if env::var(\"FASTMCP_FORCE_COLOR\").is_ok() {\n            config.force_color = Some(true);\n        }\n        if env::var(\"FASTMCP_PLAIN\").is_ok() || env::var(\"NO_COLOR\").is_ok() {\n            config.force_plain = true;\n        }\n        \n        // Banner\n        if let Ok(val) = env::var(\"FASTMCP_BANNER\") {\n            config.banner_style = match val.to_lowercase().as_str() {\n                \"full\" => BannerStyle::Full,\n                \"compact\" => BannerStyle::Compact,\n                \"minimal\" => BannerStyle::Minimal,\n                \"none\" | \"0\" | \"false\" => BannerStyle::None,\n                _ => BannerStyle::Full,\n            };\n            config.show_banner = !matches!(config.banner_style, BannerStyle::None);\n        }\n        \n        // Logging\n        if let Ok(level) = env::var(\"FASTMCP_LOG\") {\n            config.log_level = level.parse().ok();\n        }\n        if env::var(\"FASTMCP_LOG_TIMESTAMPS\").map(|v| v == \"0\").unwrap_or(false) {\n            config.log_timestamps = false;\n        }\n        \n        // Traffic\n        if let Ok(val) = env::var(\"FASTMCP_TRAFFIC\") {\n            config.traffic_verbosity = match val.to_lowercase().as_str() {\n                \"none\" | \"0\" => TrafficVerbosity::None,\n                \"summary\" | \"1\" => TrafficVerbosity::Summary,\n                \"headers\" | \"2\" => TrafficVerbosity::Headers,\n                \"full\" | \"3\" => TrafficVerbosity::Full,\n                _ => TrafficVerbosity::None,\n            };\n            config.show_request_traffic = !matches!(config.traffic_verbosity, TrafficVerbosity::None);\n        }\n        \n        // Errors\n        if env::var(\"RUST_BACKTRACE\").is_ok() {\n            config.show_backtrace = true;\n        }\n        \n        config\n    }\n    \n    // Builder methods\n    \n    pub fn with_theme(mut self, theme: FastMcpTheme) -> Self {\n        self.theme = theme;\n        self\n    }\n    \n    pub fn force_color(mut self, force: bool) -> Self {\n        self.force_color = Some(force);\n        self\n    }\n    \n    pub fn plain_mode(mut self) -> Self {\n        self.force_plain = true;\n        self\n    }\n    \n    pub fn with_banner(mut self, style: BannerStyle) -> Self {\n        self.banner_style = style;\n        self.show_banner = !matches!(style, BannerStyle::None);\n        self\n    }\n    \n    pub fn without_banner(mut self) -> Self {\n        self.show_banner = false;\n        self.banner_style = BannerStyle::None;\n        self\n    }\n    \n    pub fn with_log_level(mut self, level: tracing::Level) -> Self {\n        self.log_level = Some(level);\n        self\n    }\n    \n    pub fn with_traffic(mut self, verbosity: TrafficVerbosity) -> Self {\n        self.traffic_verbosity = verbosity;\n        self.show_request_traffic = !matches!(verbosity, TrafficVerbosity::None);\n        self\n    }\n    \n    pub fn with_periodic_stats(mut self, interval_secs: u64) -> Self {\n        self.show_stats_periodic = true;\n        self.stats_interval_secs = interval_secs;\n        self\n    }\n    \n    pub fn without_suggestions(mut self) -> Self {\n        self.show_suggestions = false;\n        self\n    }\n    \n    /// Resolve the display context based on config and environment\n    pub fn resolve_context(&self) -> DisplayContext {\n        if self.force_plain {\n            return DisplayContext::new_agent();\n        }\n        if let Some(true) = self.force_color {\n            return DisplayContext::new_human();\n        }\n        self.context.clone().unwrap_or_else(DisplayContext::detect)\n    }\n}\n```\n\n### Environment Variables\n\n| Variable | Values | Description |\n|----------|--------|-------------|\n| FASTMCP_FORCE_COLOR | (set) | Force rich output |\n| FASTMCP_PLAIN | (set) | Force plain output |\n| NO_COLOR | (set) | Disable colors (standard) |\n| FASTMCP_BANNER | full/compact/minimal/none | Banner style |\n| FASTMCP_LOG | trace/debug/info/warn/error | Log level |\n| FASTMCP_LOG_TIMESTAMPS | 0/1 | Show timestamps |\n| FASTMCP_TRAFFIC | none/summary/headers/full | Traffic logging |\n| RUST_BACKTRACE | 1/full | Show backtraces |\n\n### Usage Example\n\n```rust\nuse fastmcp_console::ConsoleConfig;\n\n// From environment (recommended for production)\nlet config = ConsoleConfig::from_env();\n\n// Programmatic configuration\nlet config = ConsoleConfig::new()\n    .with_banner(BannerStyle::Compact)\n    .with_log_level(tracing::Level::DEBUG)\n    .with_traffic(TrafficVerbosity::Summary)\n    .with_periodic_stats(30);\n\n// Use with Server\nlet server = Server::new(\"my-server\")\n    .with_console_config(config);\n```\n\n## Implementation Steps\n\n1. Create config.rs in crates/fastmcp-console/src/\n2. Define ConsoleConfig with all fields\n3. Implement Default trait\n4. Implement from_env() for environment parsing\n5. Implement all builder methods\n6. Add resolve_context() method\n7. Document all environment variables\n8. Add validation for config values\n\n## Acceptance Criteria\n\n- [ ] All display features are configurable\n- [ ] Environment variables are parsed correctly\n- [ ] Builder pattern is ergonomic\n- [ ] Defaults are sensible for production\n- [ ] resolve_context() handles all cases\n- [ ] Invalid values fall back to defaults\n- [ ] Config is Clone and Debug\n\n## Dependencies\n\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:19:33.620209206Z","created_by":"ubuntu","updated_at":"2026-01-20T04:00:49.599911977Z","closed_at":"2026-01-20T04:00:49.599867683Z","close_reason":"Implemented ConsoleConfig with builder pattern, env var parsing, and tests","source_repo":".","compaction_level":0,"original_size":0,"labels":["api","config","phase-9","rich-rust"],"dependencies":[{"issue_id":"bd-3op","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:20:09.884810416Z","created_by":"ubuntu"},{"issue_id":"bd-3op","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:19:33.665626487Z","created_by":"ubuntu"},{"issue_id":"bd-3op","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:20:10.044809251Z","created_by":"ubuntu"}]}
{"id":"bd-3ps","title":"Outcome mapping: use Outcome in handler pipeline + response mapping","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T02:28:01.891887996Z","created_by":"ubuntu","updated_at":"2026-01-25T03:50:28.313996351Z","closed_at":"2026-01-25T03:50:28.313978146Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-3s3","title":"Integrate startup banner into Server::run_stdio()","description":"# Integrate Startup Banner into Server::run_stdio()\n\n## Purpose\nWire the StartupBanner into the server's startup sequence so it displays automatically when a FastMCP server starts. This is where all the rich console work becomes visible to users.\n\n## Integration Point\nThe banner should display:\n1. AFTER the server is fully initialized (all tools/resources/prompts registered)\n2. AFTER the transport is ready\n3. BEFORE entering the main message loop\n4. ONLY if not suppressed via environment variable\n\n## Code Changes Required\n\n### In crates/fastmcp-server/src/lib.rs\n\n```rust\nuse fastmcp_console::{console, banner::StartupBanner};\n\nimpl Server {\n    pub fn run_stdio(self) -> ! {\n        // Check if banner should be shown\n        let show_banner = !std::env::var(\"FASTMCP_NO_BANNER\")\n            .map(|v| matches!(v.to_lowercase().as_str(), \"1\" | \"true\" | \"yes\"))\n            .unwrap_or(false);\n\n        // Display startup banner to humans (writes to stderr)\n        if show_banner {\n            StartupBanner::new(&self.info.name, &self.info.version)\n                .description(self.instructions.as_deref().unwrap_or(\"\"))\n                .tools(self.router.tools_count())\n                .resources(self.router.resources_count())\n                .prompts(self.router.prompts_count())\n                .transport(\"stdio\")\n                .render(console());\n        }\n\n        // Continue with normal stdio operation\n        self.run_stdio_internal()\n    }\n\n    fn run_stdio_internal(self) -> ! {\n        // ... existing implementation ...\n    }\n}\n```\n\n### Add Counter Methods to Router\n\nThe Router needs methods to count registered handlers:\n\n```rust\n// In crates/fastmcp-server/src/router.rs\n\nimpl Router {\n    /// Get the number of registered tools\n    pub fn tools_count(&self) -> usize {\n        self.tools.len()\n    }\n\n    /// Get the number of registered resources\n    pub fn resources_count(&self) -> usize {\n        self.resources.len()\n    }\n\n    /// Get the number of registered prompts\n    pub fn prompts_count(&self) -> usize {\n        self.prompts.len()\n    }\n}\n```\n\n### Add Dependency to fastmcp-server Cargo.toml\n\n```toml\n[dependencies]\nfastmcp-console = { path = \"../fastmcp-console\" }\n```\n\n## Why This Location?\n\n### Why in run_stdio()?\n- Called once at startup\n- Has access to all server state\n- Before the blocking message loop\n- Easy to skip with environment variable\n\n### Why Not in ServerBuilder::build()?\n- Server might be used without stdio\n- Other transports (SSE, WebSocket) may have different banners\n- Better separation of concerns\n\n### Why Not in main()?\n- Would require passing counts separately\n- Less ergonomic API\n- Server knows its own capabilities\n\n## Environment Variable: FASTMCP_NO_BANNER\n\nPurpose: Allow users to suppress the banner entirely.\n\nUse cases:\n1. Agents that watch stderr and don't want extra output\n2. Scripts that parse server output\n3. Users who prefer minimal output\n4. CI environments that want quiet startup\n\n## Timing Considerations\n\nThe banner MUST render quickly:\n- Should complete in < 10ms\n- No network calls\n- No file I/O (except terminal detection)\n- No async operations\n\nIf the banner is slow, it delays the server becoming ready, which affects agent startup times.\n\n## Error Handling\n\nBanner rendering should NEVER crash the server:\n\n```rust\nif show_banner {\n    // Wrap in catch_unwind for safety\n    if let Err(e) = std::panic::catch_unwind(|| {\n        StartupBanner::new(...)\n            .render(console());\n    }) {\n        // Log but don't crash\n        eprintln!(\"Warning: banner rendering failed: {:?}\", e);\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Banner displays when server starts with stdio transport\n- [ ] Banner is suppressed when FASTMCP_NO_BANNER=1\n- [ ] Banner shows correct tool/resource/prompt counts\n- [ ] Banner shows server name and version\n- [ ] Banner shows instructions/description if set\n- [ ] Router exposes count methods\n- [ ] fastmcp-console is a dependency of fastmcp-server\n- [ ] No panics from banner rendering can crash server\n\n## Testing\n\n```rust\n#[test]\nfn test_banner_suppression() {\n    std::env::set_var(\"FASTMCP_NO_BANNER\", \"1\");\n    // Start server, capture stderr\n    // Assert stderr is empty (except for logging)\n    std::env::remove_var(\"FASTMCP_NO_BANNER\");\n}\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:07:41.833482235Z","created_by":"ubuntu","updated_at":"2026-01-20T04:07:45.517564628Z","closed_at":"2026-01-20T04:07:45.517518511Z","close_reason":"Integrated StartupBanner into Server::run_stdio","source_repo":".","compaction_level":0,"original_size":0,"labels":["banner","integration","phase-2","rich-rust"],"dependencies":[{"issue_id":"bd-3s3","depends_on_id":"bd-2w6","type":"blocks","created_at":"2026-01-19T21:09:10.138082158Z","created_by":"ubuntu"},{"issue_id":"bd-3s3","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:07:41.868641673Z","created_by":"ubuntu"}]}
{"id":"bd-3sy","title":"Implement RequestResponseRenderer for traffic visualization","description":"## Purpose and Rationale\n\nCreate a renderer that displays JSON-RPC request/response traffic in a beautiful, readable format. This is invaluable for debugging and understanding what's happening in real-time.\n\n## Background\n\nWhen debugging MCP servers, seeing the actual requests and responses is crucial. Raw JSON is hard to read; a formatted display with syntax highlighting, timing info, and clear request/response pairing makes debugging much easier.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/client/traffic.rs\n\nuse rich_rust::{Panel, Rule, Style};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse fastmcp::protocol::{JsonRpcRequest, JsonRpcResponse};\nuse std::time::{Duration, Instant};\n\n/// Renders request/response traffic beautifully\npub struct RequestResponseRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n    show_params: bool,\n    show_result: bool,\n    truncate_at: usize,\n    show_timing: bool,\n}\n\nimpl RequestResponseRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            theme,\n            context,\n            show_params: true,\n            show_result: true,\n            truncate_at: 200,\n            show_timing: true,\n        }\n    }\n    \n    /// Render an incoming request\n    pub fn render_request(&self, request: &JsonRpcRequest, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_request_plain(request, console);\n            return;\n        }\n        \n        let method_style = self.method_style(&request.method);\n        \n        // Request header\n        console.print(&format!(\n            \"\\n[bold]â†’[/] [{}]{}[/] [dim]id={}[/]\",\n            method_style,\n            request.method,\n            self.format_id(&request.id)\n        ));\n        \n        // Parameters (if enabled and present)\n        if self.show_params {\n            if let Some(params) = &request.params {\n                self.render_json_preview(\"Params\", params, console);\n            }\n        }\n    }\n    \n    /// Render an outgoing response\n    pub fn render_response(\n        &self, \n        response: &JsonRpcResponse, \n        duration: Option<Duration>,\n        console: &FastMcpConsole\n    ) {\n        if !self.context.should_use_rich() {\n            self.render_response_plain(response, duration, console);\n            return;\n        }\n        \n        // Determine response type and style\n        let (icon, status, style) = if response.error.is_some() {\n            (\"âœ—\", \"error\", self.theme.error_style().to_markup())\n        } else {\n            (\"âœ“\", \"ok\", self.theme.success_style().to_markup())\n        };\n        \n        // Response header\n        let timing = if self.show_timing {\n            duration.map(|d| format!(\" [dim]({})[/]\", self.format_duration(d)))\n                .unwrap_or_default()\n        } else {\n            String::new()\n        };\n        \n        console.print(&format!(\n            \"[bold]â†[/] [{}]{} {}[/] [dim]id={}[/]{}\",\n            style,\n            icon,\n            status,\n            self.format_id(&response.id),\n            timing\n        ));\n        \n        // Result or error\n        if self.show_result {\n            if let Some(error) = &response.error {\n                self.render_error_preview(error, console);\n            } else if let Some(result) = &response.result {\n                self.render_json_preview(\"Result\", result, console);\n            }\n        }\n    }\n    \n    /// Render a request/response pair together\n    pub fn render_pair(\n        &self,\n        request: &JsonRpcRequest,\n        response: &JsonRpcResponse,\n        duration: Duration,\n        console: &FastMcpConsole,\n    ) {\n        if !self.context.should_use_rich() {\n            self.render_pair_plain(request, response, duration, console);\n            return;\n        }\n        \n        // Combined display\n        let status_icon = if response.error.is_some() { \"âœ—\" } else { \"âœ“\" };\n        let status_style = if response.error.is_some() {\n            self.theme.error_style().to_markup()\n        } else {\n            self.theme.success_style().to_markup()\n        };\n        \n        console.print(&format!(\n            \"[bold cyan]{}[/] [{}]{}[/] [dim]{}[/]\",\n            request.method,\n            status_style,\n            status_icon,\n            self.format_duration(duration)\n        ));\n    }\n    \n    fn render_json_preview(&self, label: &str, value: &serde_json::Value, console: &FastMcpConsole) {\n        let json_str = serde_json::to_string_pretty(value).unwrap_or_default();\n        let preview = self.truncate_string(&json_str);\n        \n        console.print(&format!(\"  [dim]{}:[/]\", label));\n        for line in preview.lines() {\n            console.print(&format!(\"    [dim]{}[/]\", line));\n        }\n    }\n    \n    fn render_error_preview(&self, error: &JsonRpcError, console: &FastMcpConsole) {\n        console.print(&format!(\n            \"  [red]Error {}[/]: {}\",\n            error.code,\n            error.message\n        ));\n        \n        if let Some(data) = &error.data {\n            console.print(&format!(\"  [dim]Data: {}[/]\", self.truncate_string(&data.to_string())));\n        }\n    }\n    \n    fn method_style(&self, method: &str) -> String {\n        // Color-code by method category\n        if method.starts_with(\"tools/\") {\n            \"cyan\"\n        } else if method.starts_with(\"resources/\") {\n            \"green\"\n        } else if method.starts_with(\"prompts/\") {\n            \"magenta\"\n        } else if method.starts_with(\"initialize\") || method.starts_with(\"shutdown\") {\n            \"yellow\"\n        } else {\n            \"white\"\n        }.to_string()\n    }\n    \n    fn format_id(&self, id: &Option<serde_json::Value>) -> String {\n        id.as_ref()\n            .map(|v| v.to_string())\n            .unwrap_or_else(|| \"null\".to_string())\n    }\n    \n    fn format_duration(&self, d: Duration) -> String {\n        let micros = d.as_micros();\n        if micros < 1000 {\n            format!(\"{}Î¼s\", micros)\n        } else if micros < 1_000_000 {\n            format!(\"{:.1}ms\", micros as f64 / 1000.0)\n        } else {\n            format!(\"{:.2}s\", micros as f64 / 1_000_000.0)\n        }\n    }\n    \n    fn truncate_string(&self, s: &str) -> String {\n        if s.len() <= self.truncate_at {\n            s.to_string()\n        } else {\n            format!(\"{}...\", &s[..self.truncate_at])\n        }\n    }\n    \n    fn render_request_plain(&self, request: &JsonRpcRequest, console: &FastMcpConsole) {\n        console.print(&format!(\"-> {} (id={})\", request.method, self.format_id(&request.id)));\n    }\n    \n    fn render_response_plain(&self, response: &JsonRpcResponse, duration: Option<Duration>, console: &FastMcpConsole) {\n        let status = if response.error.is_some() { \"error\" } else { \"ok\" };\n        let timing = duration.map(|d| format!(\" ({})\", self.format_duration(d))).unwrap_or_default();\n        console.print(&format!(\"<- {} (id={}){}\", status, self.format_id(&response.id), timing));\n    }\n    \n    fn render_pair_plain(&self, request: &JsonRpcRequest, response: &JsonRpcResponse, duration: Duration, console: &FastMcpConsole) {\n        let status = if response.error.is_some() { \"FAIL\" } else { \"OK\" };\n        console.print(&format!(\"{} [{}] {}\", request.method, status, self.format_duration(duration)));\n    }\n}\n```\n\n### Visual Example\n\n```\nâ†’ tools/call id=1\n  Params:\n    {\n      \"name\": \"calculate\",\n      \"arguments\": {\"a\": 5, \"b\": 3}\n    }\n\nâ† âœ“ ok id=1 (2.3ms)\n  Result:\n    {\n      \"result\": 8\n    }\n\ntools/call âœ“ 2.3ms\n```\n\n## Implementation Steps\n\n1. Create client/traffic.rs\n2. Implement render_request() for incoming requests\n3. Implement render_response() for outgoing responses\n4. Implement render_pair() for combined display\n5. Add JSON preview with truncation\n6. Add error preview formatting\n7. Add method color-coding\n8. Implement plain-text fallbacks\n\n## Acceptance Criteria\n\n- [ ] Requests display method and ID\n- [ ] Responses show status and timing\n- [ ] JSON is prettified and truncated\n- [ ] Errors are highlighted distinctly\n- [ ] Methods are color-coded by type\n- [ ] Timing is formatted appropriately\n- [ ] Plain-text fallback works\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:17:21.045681251Z","created_by":"ubuntu","updated_at":"2026-01-21T10:19:49.424175769Z","closed_at":"2026-01-21T10:19:49.424131265Z","close_reason":"Already implemented; verified renderer present","source_repo":".","compaction_level":0,"original_size":0,"labels":["client","phase-7","requests","rich-rust"],"dependencies":[{"issue_id":"bd-3sy","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:17:29.471919458Z","created_by":"ubuntu"},{"issue_id":"bd-3sy","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:17:21.085873425Z","created_by":"ubuntu"},{"issue_id":"bd-3sy","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:17:29.311139621Z","created_by":"ubuntu"},{"issue_id":"bd-3sy","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:17:29.604433265Z","created_by":"ubuntu"}]}
{"id":"bd-5gw","title":"Implement ToolTableRenderer for tool registry display","description":"## Purpose and Rationale\n\nCreate a renderer that displays registered tools in a beautiful table format using rich_rust. This helps developers and operators quickly see what capabilities a server exposes.\n\n## Background\n\nMCP servers expose tools that clients can call. Seeing the complete list of tools with their descriptions, parameters, and types in a well-formatted table is essential for understanding what a server can do. This is particularly useful during development and debugging.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/handlers/tool_table.rs\n\nuse rich_rust::{Table, Column, Panel, JustifyMethod, Style};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse fastmcp::tool::ToolInfo;\n\n/// Renders tool registry as beautiful tables\npub struct ToolTableRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n    show_parameters: bool,\n    show_return_type: bool,\n    max_description_width: usize,\n}\n\nimpl ToolTableRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            theme,\n            context,\n            show_parameters: true,\n            show_return_type: true,\n            max_description_width: 50,\n        }\n    }\n    \n    /// Render a collection of tools as a table\n    pub fn render(&self, tools: &[ToolInfo], console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(tools, console);\n            return;\n        }\n        \n        if tools.is_empty() {\n            console.print(\"[dim]No tools registered[/]\");\n            return;\n        }\n        \n        let mut table = Table::new()\n            .title(format!(\"ðŸ“¦ Registered Tools ({})\", tools.len()))\n            .with_column(Column::new(\"Name\").style(self.theme.primary_style()))\n            .with_column(Column::new(\"Description\").max_width(self.max_description_width))\n            .with_column(Column::new(\"Parameters\").justify(JustifyMethod::Center));\n        \n        if self.show_return_type {\n            table = table.with_column(Column::new(\"Returns\"));\n        }\n        \n        for tool in tools {\n            let name = &tool.name;\n            let desc = self.truncate_description(&tool.description);\n            let params = self.format_parameters(&tool.parameters);\n            \n            if self.show_return_type {\n                let returns = self.format_return_type(&tool.return_type);\n                table.add_row_cells([name.as_str(), &desc, &params, &returns]);\n            } else {\n                table.add_row_cells([name.as_str(), &desc, &params]);\n            }\n        }\n        \n        console.print_renderable(&table);\n    }\n    \n    /// Render a single tool in detail\n    pub fn render_detail(&self, tool: &ToolInfo, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_detail_plain(tool, console);\n            return;\n        }\n        \n        // Tool name header\n        console.print(&format!(\"\\n[bold cyan]{}[/]\", tool.name));\n        console.print(&format!(\"[dim]{}[/]\\n\", tool.description));\n        \n        // Parameters table\n        if !tool.parameters.is_empty() {\n            let mut param_table = Table::new()\n                .title(\"Parameters\")\n                .with_column(Column::new(\"Name\").style(self.theme.primary_style()))\n                .with_column(Column::new(\"Type\"))\n                .with_column(Column::new(\"Required\").justify(JustifyMethod::Center))\n                .with_column(Column::new(\"Description\"));\n            \n            for param in &tool.parameters {\n                let required = if param.required { \"âœ“\" } else { \"\" };\n                param_table.add_row_cells([\n                    param.name.as_str(),\n                    &param.type_name,\n                    required,\n                    &param.description.as_deref().unwrap_or(\"\"),\n                ]);\n            }\n            \n            console.print_renderable(&param_table);\n        }\n        \n        // Return type\n        if let Some(ret) = &tool.return_type {\n            console.print(&format!(\"\\n[dim]Returns:[/] {}\", ret));\n        }\n    }\n    \n    fn format_parameters(&self, params: &[ParameterInfo]) -> String {\n        if params.is_empty() {\n            \"none\".to_string()\n        } else {\n            let required = params.iter().filter(|p| p.required).count();\n            let optional = params.len() - required;\n            \n            match (required, optional) {\n                (r, 0) => format!(\"{} required\", r),\n                (0, o) => format!(\"{} optional\", o),\n                (r, o) => format!(\"{} required, {} optional\", r, o),\n            }\n        }\n    }\n    \n    fn truncate_description(&self, desc: &str) -> String {\n        if desc.len() <= self.max_description_width {\n            desc.to_string()\n        } else {\n            format!(\"{}...\", &desc[..self.max_description_width - 3])\n        }\n    }\n    \n    fn format_return_type(&self, ret: &Option<String>) -> String {\n        ret.as_deref().unwrap_or(\"-\").to_string()\n    }\n    \n    fn render_plain(&self, tools: &[ToolInfo], console: &FastMcpConsole) {\n        console.print(&format!(\"Registered Tools ({})\", tools.len()));\n        console.print(&\"=\".repeat(40));\n        for tool in tools {\n            console.print(&format!(\"  {} - {}\", tool.name, tool.description));\n        }\n    }\n    \n    fn render_detail_plain(&self, tool: &ToolInfo, console: &FastMcpConsole) {\n        console.print(&format!(\"Tool: {}\", tool.name));\n        console.print(&format!(\"Description: {}\", tool.description));\n        for param in &tool.parameters {\n            let req = if param.required { \"required\" } else { \"optional\" };\n            console.print(&format!(\"  - {}: {} ({})\", param.name, param.type_name, req));\n        }\n    }\n}\n```\n\n### Visual Example\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ“¦ Registered Tools (5) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Name              â”‚ Description                      â”‚ Parameters â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ calculate         â”‚ Perform mathematical calculationsâ”‚ 2 required â”‚\nâ”‚ search_files      â”‚ Search for files matching a pat..â”‚ 1 req, 2 optâ”‚\nâ”‚ read_file         â”‚ Read contents of a file          â”‚ 1 required â”‚\nâ”‚ write_file        â”‚ Write contents to a file         â”‚ 2 required â”‚\nâ”‚ list_directory    â”‚ List contents of a directory     â”‚ 1 required â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Implementation Steps\n\n1. Create handlers/tool_table.rs\n2. Implement render() for table view\n3. Implement render_detail() for single tool\n4. Add parameter formatting logic\n5. Add description truncation\n6. Implement plain-text fallback\n7. Add configuration options\n8. Test with various tool sets\n\n## Acceptance Criteria\n\n- [ ] Table displays all tools correctly\n- [ ] Parameter counts are accurate\n- [ ] Descriptions truncate gracefully\n- [ ] Detail view shows all parameters\n- [ ] Plain-text fallback is functional\n- [ ] Empty tool list handled gracefully\n- [ ] Colors follow theme consistently\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:14:28.992831715Z","created_by":"ubuntu","updated_at":"2026-01-21T10:51:23.420583031Z","closed_at":"2026-01-21T10:51:23.420538597Z","close_reason":"ToolTableRenderer fully implemented in tables.rs with: render() for table view showing tools with parameters, render_detail() for single tool view with parameters table, plain-text fallbacks, parameter extraction from JSON Schema, description truncation, and comprehensive tests. All acceptance criteria met.","source_repo":".","compaction_level":0,"original_size":0,"labels":["phase-6","rich-rust","tables","tools"],"dependencies":[{"issue_id":"bd-5gw","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:15:58.524339414Z","created_by":"ubuntu"},{"issue_id":"bd-5gw","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:14:29.029807604Z","created_by":"ubuntu"},{"issue_id":"bd-5gw","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:15:58.309708797Z","created_by":"ubuntu"},{"issue_id":"bd-5gw","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:15:58.745787137Z","created_by":"ubuntu"}]}
{"id":"bd-6sq","title":"Implement ServerStats struct for runtime metrics","description":"## Purpose and Rationale\n\nCreate a data structure that tracks server runtime metrics (requests, connections, timing, etc.) which will be displayed using rich_rust components. This separates data collection from presentation.\n\n## Background\n\nA premium MCP server experience requires visibility into what the server is doing. Metrics like request counts, average latency, active connections, and uptime help both developers and operators understand server health. These metrics will be rendered as beautiful tables and panels.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/stats/mod.rs\n\nuse std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\n/// Thread-safe server statistics collector\n#[derive(Debug, Clone)]\npub struct ServerStats {\n    inner: Arc<ServerStatsInner>,\n}\n\n#[derive(Debug)]\nstruct ServerStatsInner {\n    // Timing\n    start_time: Instant,\n    \n    // Request counters\n    total_requests: AtomicU64,\n    successful_requests: AtomicU64,\n    failed_requests: AtomicU64,\n    cancelled_requests: AtomicU64,\n    \n    // By method type\n    tool_calls: AtomicU64,\n    resource_reads: AtomicU64,\n    prompt_gets: AtomicU64,\n    list_operations: AtomicU64,\n    \n    // Latency tracking (approximate)\n    total_latency_micros: AtomicU64,\n    max_latency_micros: AtomicU64,\n    min_latency_micros: AtomicU64,\n    \n    // Connection state\n    active_connections: AtomicUsize,\n    total_connections: AtomicU64,\n    \n    // Data transfer\n    bytes_received: AtomicU64,\n    bytes_sent: AtomicU64,\n}\n\nimpl ServerStats {\n    pub fn new() -> Self {\n        Self {\n            inner: Arc::new(ServerStatsInner {\n                start_time: Instant::now(),\n                total_requests: AtomicU64::new(0),\n                successful_requests: AtomicU64::new(0),\n                failed_requests: AtomicU64::new(0),\n                cancelled_requests: AtomicU64::new(0),\n                tool_calls: AtomicU64::new(0),\n                resource_reads: AtomicU64::new(0),\n                prompt_gets: AtomicU64::new(0),\n                list_operations: AtomicU64::new(0),\n                total_latency_micros: AtomicU64::new(0),\n                max_latency_micros: AtomicU64::new(0),\n                min_latency_micros: AtomicU64::new(u64::MAX),\n                active_connections: AtomicUsize::new(0),\n                total_connections: AtomicU64::new(0),\n                bytes_received: AtomicU64::new(0),\n                bytes_sent: AtomicU64::new(0),\n            }),\n        }\n    }\n    \n    /// Record a completed request\n    pub fn record_request(&self, method: &str, latency: Duration, success: bool) {\n        self.inner.total_requests.fetch_add(1, Ordering::Relaxed);\n        \n        if success {\n            self.inner.successful_requests.fetch_add(1, Ordering::Relaxed);\n        } else {\n            self.inner.failed_requests.fetch_add(1, Ordering::Relaxed);\n        }\n        \n        // Track by method type\n        match method {\n            m if m.starts_with(\"tools/\") => {\n                self.inner.tool_calls.fetch_add(1, Ordering::Relaxed);\n            }\n            m if m.starts_with(\"resources/\") => {\n                self.inner.resource_reads.fetch_add(1, Ordering::Relaxed);\n            }\n            m if m.starts_with(\"prompts/\") => {\n                self.inner.prompt_gets.fetch_add(1, Ordering::Relaxed);\n            }\n            _ if method.contains(\"list\") => {\n                self.inner.list_operations.fetch_add(1, Ordering::Relaxed);\n            }\n            _ => {}\n        }\n        \n        // Track latency\n        let micros = latency.as_micros() as u64;\n        self.inner.total_latency_micros.fetch_add(micros, Ordering::Relaxed);\n        self.inner.max_latency_micros.fetch_max(micros, Ordering::Relaxed);\n        self.inner.min_latency_micros.fetch_min(micros, Ordering::Relaxed);\n    }\n    \n    /// Get a snapshot for display\n    pub fn snapshot(&self) -> StatsSnapshot {\n        let total = self.inner.total_requests.load(Ordering::Relaxed);\n        let total_latency = self.inner.total_latency_micros.load(Ordering::Relaxed);\n        \n        StatsSnapshot {\n            uptime: self.inner.start_time.elapsed(),\n            total_requests: total,\n            successful_requests: self.inner.successful_requests.load(Ordering::Relaxed),\n            failed_requests: self.inner.failed_requests.load(Ordering::Relaxed),\n            cancelled_requests: self.inner.cancelled_requests.load(Ordering::Relaxed),\n            tool_calls: self.inner.tool_calls.load(Ordering::Relaxed),\n            resource_reads: self.inner.resource_reads.load(Ordering::Relaxed),\n            prompt_gets: self.inner.prompt_gets.load(Ordering::Relaxed),\n            avg_latency: if total > 0 {\n                Duration::from_micros(total_latency / total)\n            } else {\n                Duration::ZERO\n            },\n            max_latency: Duration::from_micros(self.inner.max_latency_micros.load(Ordering::Relaxed)),\n            active_connections: self.inner.active_connections.load(Ordering::Relaxed),\n            bytes_received: self.inner.bytes_received.load(Ordering::Relaxed),\n            bytes_sent: self.inner.bytes_sent.load(Ordering::Relaxed),\n        }\n    }\n}\n\n/// Point-in-time snapshot of server statistics\n#[derive(Debug, Clone)]\npub struct StatsSnapshot {\n    pub uptime: Duration,\n    pub total_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub cancelled_requests: u64,\n    pub tool_calls: u64,\n    pub resource_reads: u64,\n    pub prompt_gets: u64,\n    pub avg_latency: Duration,\n    pub max_latency: Duration,\n    pub active_connections: usize,\n    pub bytes_received: u64,\n    pub bytes_sent: u64,\n}\n```\n\n### Usage Pattern\n\n```rust\n// In request handler\nlet start = Instant::now();\nlet result = handle_request(request).await;\nstats.record_request(request.method(), start.elapsed(), result.is_ok());\n```\n\n## Implementation Steps\n\n1. Create stats/mod.rs in crates/fastmcp-console/src/\n2. Implement ServerStats with atomic counters\n3. Implement record_* methods for various events\n4. Implement snapshot() for point-in-time reads\n5. Add helper methods for formatted display values\n6. Add comprehensive tests for thread-safety\n7. Document public API\n\n## Acceptance Criteria\n\n- [ ] All counters are thread-safe (atomic)\n- [ ] record_request() tracks all relevant metrics\n- [ ] snapshot() provides consistent point-in-time view\n- [ ] Latency tracking is accurate\n- [ ] Method-type breakdown works correctly\n- [ ] Clone is cheap (Arc-based)\n- [ ] Memory footprint is minimal\n\n## Testing Strategy\n\n```rust\n#[test]\nfn test_concurrent_updates() {\n    let stats = ServerStats::new();\n    let stats_clone = stats.clone();\n    \n    std::thread::spawn(move || {\n        for _ in 0..1000 {\n            stats_clone.record_request(\"tools/call\", Duration::from_millis(10), true);\n        }\n    });\n    \n    for _ in 0..1000 {\n        stats.record_request(\"resources/read\", Duration::from_millis(5), true);\n    }\n    \n    // Wait and verify\n    std::thread::sleep(Duration::from_millis(100));\n    let snap = stats.snapshot();\n    assert_eq!(snap.total_requests, 2000);\n}\n```\n\n## Dependencies\n\n- Standalone data structure, no rich_rust dependencies\n- Will be used by StatsRenderer (next task)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:11:24.192692185Z","created_by":"ubuntu","updated_at":"2026-01-20T04:22:51.767132327Z","closed_at":"2026-01-20T04:22:51.767046756Z","close_reason":"Implemented ServerStats with Arc<Inner>, atomic counters, record_request/cancelled methods, connection tracking, byte tracking, and 3 comprehensive tests including concurrent update test","source_repo":".","compaction_level":0,"original_size":0,"labels":["metrics","phase-4","rich-rust","stats"],"dependencies":[{"issue_id":"bd-6sq","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:11:24.236349693Z","created_by":"ubuntu"},{"issue_id":"bd-6sq","depends_on_id":"bd-3h3","type":"blocks","created_at":"2026-01-19T21:22:52.059530951Z","created_by":"ubuntu"}]}
{"id":"bd-7uw","title":"Add Server run methods for SSE and WebSocket transports","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:08:08.130708067Z","created_by":"ubuntu","updated_at":"2026-01-25T02:37:10.737402142Z","closed_at":"2026-01-25T02:37:10.736603838Z","close_reason":"Added Server run_transport/run_sse/run_websocket and Transport impl for WsTransport","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-8bz","title":"Fix rich_rust console.rs duplicate write_control_codes compile error","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-25T02:41:19.426373571Z","created_by":"ubuntu","updated_at":"2026-01-25T04:44:22.035848719Z","closed_at":"2026-01-25T04:44:22.035830444Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-j5u","title":"Implement ResourceTableRenderer for resource registry display","description":"## Purpose and Rationale\n\nCreate a renderer that displays registered resources in a beautiful table format using rich_rust. Resources are data endpoints that clients can read, and visualizing them helps developers understand the server's data exposure.\n\n## Background\n\nMCP resources represent data that can be read by clients (like files, database records, API responses). Displaying them in a clear table with their URIs, types, and descriptions makes it easy to understand what data a server exposes.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/handlers/resource_table.rs\n\nuse rich_rust::{Table, Column, Panel, JustifyMethod, Style, Tree, TreeNode};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse fastmcp::resource::ResourceInfo;\n\n/// Renders resource registry as beautiful tables\npub struct ResourceTableRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n    show_mime_types: bool,\n    group_by_prefix: bool,\n}\n\nimpl ResourceTableRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            theme,\n            context,\n            show_mime_types: true,\n            group_by_prefix: true,\n        }\n    }\n    \n    /// Render resources as a table\n    pub fn render(&self, resources: &[ResourceInfo], console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(resources, console);\n            return;\n        }\n        \n        if resources.is_empty() {\n            console.print(\"[dim]No resources registered[/]\");\n            return;\n        }\n        \n        let mut table = Table::new()\n            .title(format!(\"ðŸ“„ Registered Resources ({})\", resources.len()))\n            .with_column(Column::new(\"URI\").style(self.theme.primary_style()))\n            .with_column(Column::new(\"Description\").max_width(40))\n            .with_column(Column::new(\"Type\").justify(JustifyMethod::Center));\n        \n        if self.show_mime_types {\n            table = table.with_column(Column::new(\"MIME Type\"));\n        }\n        \n        for resource in resources {\n            let uri = self.format_uri(&resource.uri);\n            let desc = self.truncate(&resource.description, 40);\n            let rtype = self.format_resource_type(&resource.resource_type);\n            \n            if self.show_mime_types {\n                let mime = resource.mime_type.as_deref().unwrap_or(\"unknown\");\n                table.add_row_cells([&uri, &desc, &rtype, mime]);\n            } else {\n                table.add_row_cells([&uri, &desc, &rtype]);\n            }\n        }\n        \n        console.print_renderable(&table);\n    }\n    \n    /// Render resources as a tree grouped by URI prefix\n    pub fn render_tree(&self, resources: &[ResourceInfo], console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(resources, console);\n            return;\n        }\n        \n        if resources.is_empty() {\n            console.print(\"[dim]No resources registered[/]\");\n            return;\n        }\n        \n        // Group resources by first path segment\n        let mut groups: std::collections::HashMap<String, Vec<&ResourceInfo>> = \n            std::collections::HashMap::new();\n        \n        for resource in resources {\n            let prefix = self.extract_prefix(&resource.uri);\n            groups.entry(prefix).or_default().push(resource);\n        }\n        \n        // Build tree\n        let mut root = TreeNode::new(format!(\"ðŸ“„ Resources ({})\", resources.len()));\n        \n        for (prefix, group_resources) in &groups {\n            let mut group_node = TreeNode::new(format!(\"[cyan]{}[/] ({})\", prefix, group_resources.len()));\n            \n            for resource in group_resources {\n                let leaf = format!(\"{} [dim]- {}[/]\", \n                    resource.uri.split('/').last().unwrap_or(&resource.uri),\n                    self.truncate(&resource.description, 30));\n                group_node.add_child(TreeNode::new(leaf));\n            }\n            \n            root.add_child(group_node);\n        }\n        \n        let tree = rich_rust::Tree::new(root);\n        console.print_renderable(&tree);\n    }\n    \n    fn format_uri(&self, uri: &str) -> String {\n        // Highlight the template parts in URIs like \"file://{path}\"\n        if uri.contains('{') {\n            uri.replace('{', \"[yellow]{\").replace('}', \"}[/]\")\n        } else {\n            uri.to_string()\n        }\n    }\n    \n    fn format_resource_type(&self, rtype: &ResourceType) -> String {\n        match rtype {\n            ResourceType::Static => \"Static\".to_string(),\n            ResourceType::Template => \"Template\".to_string(),\n            ResourceType::Dynamic => \"Dynamic\".to_string(),\n        }\n    }\n    \n    fn extract_prefix(&self, uri: &str) -> String {\n        uri.split('/').next().unwrap_or(\"root\").to_string()\n    }\n    \n    fn truncate(&self, s: &str, max: usize) -> String {\n        if s.len() <= max {\n            s.to_string()\n        } else {\n            format!(\"{}...\", &s[..max - 3])\n        }\n    }\n    \n    fn render_plain(&self, resources: &[ResourceInfo], console: &FastMcpConsole) {\n        console.print(&format!(\"Registered Resources ({})\", resources.len()));\n        for resource in resources {\n            console.print(&format!(\"  {} - {}\", resource.uri, resource.description));\n        }\n    }\n}\n```\n\n### Visual Example (Table)\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ“„ Registered Resources (4) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ URI                    â”‚ Description                 â”‚   Type   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ file://{path}          â”‚ Read file contents          â”‚ Template â”‚\nâ”‚ config://settings      â”‚ Server configuration        â”‚ Static   â”‚\nâ”‚ db://users/{id}        â”‚ User record by ID           â”‚ Template â”‚\nâ”‚ cache://stats          â”‚ Cached statistics           â”‚ Dynamic  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Visual Example (Tree)\n\n```\nðŸ“„ Resources (4)\nâ”œâ”€â”€ file (1)\nâ”‚   â””â”€â”€ {path} - Read file contents\nâ”œâ”€â”€ config (1)\nâ”‚   â””â”€â”€ settings - Server configuration\nâ”œâ”€â”€ db (1)\nâ”‚   â””â”€â”€ users/{id} - User record by ID\nâ””â”€â”€ cache (1)\n    â””â”€â”€ stats - Cached statistics\n```\n\n## Implementation Steps\n\n1. Create handlers/resource_table.rs\n2. Implement render() for table view\n3. Implement render_tree() for grouped view\n4. Add URI template highlighting\n5. Add MIME type display\n6. Implement plain-text fallback\n7. Test with various resource types\n\n## Acceptance Criteria\n\n- [ ] Table displays all resources correctly\n- [ ] URI templates are highlighted\n- [ ] Tree view groups by prefix\n- [ ] MIME types shown when available\n- [ ] Plain-text fallback is functional\n- [ ] Empty resource list handled gracefully\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:14:54.752999636Z","created_by":"ubuntu","updated_at":"2026-01-21T09:20:54.292187550Z","closed_at":"2026-01-21T09:20:54.292110395Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"labels":["phase-6","resources","rich-rust","tables"],"dependencies":[{"issue_id":"bd-j5u","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:16:00.478854651Z","created_by":"ubuntu"},{"issue_id":"bd-j5u","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:14:54.793432523Z","created_by":"ubuntu"},{"issue_id":"bd-j5u","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:16:00.265574206Z","created_by":"ubuntu"},{"issue_id":"bd-j5u","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:16:00.695560916Z","created_by":"ubuntu"}]}
{"id":"bd-nuy","title":"Implement RichLogFormatter for styled log output","description":"## Purpose and Rationale\n\nCreate a sophisticated log formatting system that transforms raw tracing events into beautifully styled console output using rich_rust. This is the foundation of the logging integration phase - making logs not just readable but delightful.\n\n## Background\n\nCurrently, FastMCP uses standard tracing output which, while functional, lacks visual appeal and hierarchy. The rich_rust library provides Console, Style, and color primitives that can transform log output into premium-quality terminal display. Python Rich's logging handler demonstrates this concept brilliantly.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/logging/formatter.rs\n\nuse rich_rust::{Console, Style, Color, Panel};\nuse tracing::{Level, Event, Subscriber};\nuse crate::context::DisplayContext;\nuse crate::theme::FastMcpTheme;\n\n/// Formats tracing events into rich, styled output\npub struct RichLogFormatter {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n    show_target: bool,\n    show_timestamp: bool,\n    show_file_line: bool,\n    max_message_width: Option<usize>,\n}\n\nimpl RichLogFormatter {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            theme,\n            context,\n            show_target: true,\n            show_timestamp: true,\n            show_file_line: false,\n            max_message_width: None,\n        }\n    }\n    \n    /// Format a log event into styled segments\n    pub fn format_event(&self, event: &Event<'_>) -> FormattedLog {\n        // Extract metadata\n        let level = event.metadata().level();\n        let target = event.metadata().target();\n        let timestamp = chrono::Local::now();\n        \n        // Build styled components\n        let level_style = self.style_for_level(level);\n        let level_badge = self.format_level_badge(level, level_style);\n        let timestamp_str = self.format_timestamp(timestamp);\n        let target_str = self.format_target(target);\n        let message = self.extract_message(event);\n        \n        FormattedLog {\n            level_badge,\n            timestamp: timestamp_str,\n            target: target_str,\n            message,\n            fields: self.extract_fields(event),\n        }\n    }\n    \n    fn style_for_level(&self, level: &Level) -> Style {\n        match *level {\n            Level::ERROR => self.theme.error_style(),\n            Level::WARN => self.theme.warning_style(),\n            Level::INFO => self.theme.info_style(),\n            Level::DEBUG => self.theme.debug_style(),\n            Level::TRACE => self.theme.trace_style(),\n        }\n    }\n    \n    fn format_level_badge(&self, level: &Level, style: Style) -> String {\n        // Create badge like: [ERROR] [WARN ] [INFO ] [DEBUG] [TRACE]\n        // Padded to 5 chars for alignment\n        let text = format\\!(\"{:5}\", level.as_str());\n        if self.context.should_use_rich() {\n            format\\!(\"[{}]{}[/]\", style.to_markup(), text)\n        } else {\n            format\\!(\"[{}]\", text)\n        }\n    }\n}\n\n/// Structured log output ready for rendering\npub struct FormattedLog {\n    pub level_badge: String,\n    pub timestamp: Option<String>,\n    pub target: Option<String>,\n    pub message: String,\n    pub fields: Vec<(String, String)>,\n}\n```\n\n### Level Styling\n\nEach log level gets a distinct, semantically appropriate style:\n\n| Level | Foreground | Background | Style |\n|-------|------------|------------|-------|\n| ERROR | White | Red | Bold |\n| WARN | Black | Yellow | Bold |\n| INFO | Cyan | - | Normal |\n| DEBUG | Dim White | - | Normal |\n| TRACE | Dim Gray | - | Dim |\n\n### Field Formatting\n\nStructured fields (spans, attributes) should be formatted distinctly:\n\n```rust\nfn format_fields(&self, fields: &[(String, String)]) -> String {\n    if fields.is_empty() || \\!self.context.should_use_rich() {\n        return String::new();\n    }\n    \n    // Format as: key=value key2=value2\n    // With dim styling for keys, normal for values\n    fields.iter()\n        .map(|(k, v)| format\\!(\"[dim]{}[/]={}\", k, v))\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n```\n\n## Implementation Steps\n\n1. Create formatter.rs in crates/fastmcp-console/src/logging/\n2. Implement core RichLogFormatter struct\n3. Add level-to-style mapping using theme\n4. Implement timestamp formatting (optional, configurable)\n5. Implement target formatting (module path)\n6. Implement field extraction from tracing Events\n7. Add plain-text fallback path for agent context\n8. Add comprehensive unit tests\n\n## Acceptance Criteria\n\n- [ ] RichLogFormatter can format all 5 log levels\n- [ ] Each level has distinct, readable styling\n- [ ] Timestamps are optional and configurable\n- [ ] Target/module paths are truncatable\n- [ ] Structured fields are formatted cleanly\n- [ ] Plain-text fallback works correctly\n- [ ] Theme colors are applied consistently\n- [ ] Unit tests cover all formatting paths\n\n## Testing Strategy\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_level_badge_formatting() {\n        let formatter = RichLogFormatter::new(\n            FastMcpTheme::default(),\n            DisplayContext::new_human(),\n        );\n        // Verify each level produces correct badge\n    }\n    \n    #[test]\n    fn test_plain_fallback() {\n        let formatter = RichLogFormatter::new(\n            FastMcpTheme::default(),\n            DisplayContext::new_agent(),\n        );\n        // Verify no ANSI codes in output\n    }\n}\n```\n\n## Dependencies\n\n- Requires FastMcpTheme (bd-14i) for consistent styling\n- Requires DisplayContext (bd-nyw) for agent/human detection\n- Will be used by RichTracingSubscriber (next task)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:09:46.280182171Z","created_by":"ubuntu","updated_at":"2026-01-21T18:01:21.073879816Z","closed_at":"2026-01-21T18:01:21.073809875Z","close_reason":"Completed: Implemented RichLogFormatter with level styling, timestamp/target formatting, field extraction, plain/rich output modes, and comprehensive unit tests (14 passing)","source_repo":".","compaction_level":0,"original_size":0,"labels":["logging","phase-3","rich-rust"],"dependencies":[{"issue_id":"bd-nuy","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:10:42.814836545Z","created_by":"ubuntu"},{"issue_id":"bd-nuy","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:09:46.315460864Z","created_by":"ubuntu"},{"issue_id":"bd-nuy","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:10:42.978288964Z","created_by":"ubuntu"}]}
{"id":"bd-nyw","title":"Implement agent/human context detection module","description":"# Implement Agent/Human Context Detection Module\n\n## Purpose\nThis module is CRITICAL for the entire integration to work correctly. It determines whether rich output should be enabled based on the execution context. Getting this wrong means either:\n- Corrupting agent communication (if we style when we shouldn't)\n- Missing the opportunity to delight humans (if we don't style when we should)\n\n## The Detection Challenge\nFastMCP servers run in multiple contexts:\n1. **Agent-Spawned**: Claude Code, Codex, Cursor spawn the server as a subprocess\n2. **Human-Interactive**: Developer runs server manually in terminal\n3. **CI/CD**: Automated testing in GitHub Actions, etc.\n4. **Debugging**: Human debugging an agent-spawned server\n5. **Piped Output**: Server output piped to files or other processes\n\n## Detection Hierarchy (Order Matters\\!)\n```rust\npub fn should_enable_rich() -> bool {\n    // 1. Explicit enable always wins (debugging agent runs)\n    if env_is_truthy(\"FASTMCP_RICH\") {\n        return true;\n    }\n\n    // 2. Explicit disable\n    if env_is_truthy(\"FASTMCP_PLAIN\") {\n        return false;\n    }\n\n    // 3. NO_COLOR standard (https://no-color.org/)\n    if std::env::var(\"NO_COLOR\").is_ok() {\n        return false;\n    }\n\n    // 4. Known agent environments\n    if is_agent_context() {\n        return false;\n    }\n\n    // 5. CI environments\n    if is_ci_environment() {\n        return false;\n    }\n\n    // 6. Final check: is stderr a TTY?\n    terminal::is_stderr_terminal()\n}\n```\n\n## Implementation Details\n\n### File: crates/fastmcp-console/src/detection.rs\n\n```rust\n//\\! Agent vs Human context detection for FastMCP rich output.\n//\\!\n//\\! This module determines whether rich terminal styling should be enabled\n//\\! based on environment variables and terminal capabilities.\n\nuse rich_rust::terminal;\n\n/// Check if an environment variable is set to a truthy value\nfn env_is_truthy(name: &str) -> bool {\n    std::env::var(name)\n        .map(|v| matches\\!(v.to_lowercase().as_str(), \"1\" | \"true\" | \"yes\" | \"on\"))\n        .unwrap_or(false)\n}\n\n/// Check if running in a known AI coding agent context\npub fn is_agent_context() -> bool {\n    // MCP client indicators (set by spawning agent)\n    std::env::var(\"MCP_CLIENT\").is_ok()\n        // Specific agent indicators\n        || std::env::var(\"CLAUDE_CODE\").is_ok()\n        || std::env::var(\"CLAUDE_CODE_SESSION\").is_ok()\n        || std::env::var(\"CODEX_CLI\").is_ok()\n        || std::env::var(\"CODEX_SESSION\").is_ok()\n        || std::env::var(\"CURSOR_SESSION\").is_ok()\n        || std::env::var(\"AIDER_SESSION\").is_ok()\n        // Generic agent indicator\n        || std::env::var(\"AGENT_MODE\").is_ok()\n        // VSCode integrated terminal with Copilot\n        || std::env::var(\"VSCODE_GIT_IPC_HANDLE\").is_ok()\n            && std::env::var(\"GITHUB_COPILOT\").is_ok()\n}\n\n/// Check if running in CI/CD environment\npub fn is_ci_environment() -> bool {\n    std::env::var(\"CI\").is_ok()\n        || std::env::var(\"GITHUB_ACTIONS\").is_ok()\n        || std::env::var(\"GITLAB_CI\").is_ok()\n        || std::env::var(\"CIRCLECI\").is_ok()\n        || std::env::var(\"TRAVIS\").is_ok()\n        || std::env::var(\"JENKINS_URL\").is_ok()\n        || std::env::var(\"BUILDKITE\").is_ok()\n}\n\n/// Determine if rich output should be enabled\npub fn should_enable_rich() -> bool {\n    // Implementation as above...\n}\n\n/// Get the reason why rich output is enabled/disabled (for debugging)\npub fn detection_reason() -> &'static str {\n    if env_is_truthy(\"FASTMCP_RICH\") {\n        return \"FASTMCP_RICH=1 (forced on)\";\n    }\n    if env_is_truthy(\"FASTMCP_PLAIN\") {\n        return \"FASTMCP_PLAIN=1 (forced off)\";\n    }\n    if std::env::var(\"NO_COLOR\").is_ok() {\n        return \"NO_COLOR set (standard compliance)\";\n    }\n    if is_agent_context() {\n        return \"Agent context detected\";\n    }\n    if is_ci_environment() {\n        return \"CI environment detected\";\n    }\n    if terminal::is_stderr_terminal() {\n        \"stderr is TTY (human likely watching)\"\n    } else {\n        \"stderr is not TTY (output likely piped)\"\n    }\n}\n```\n\n## Why These Specific Checks?\n\n### FASTMCP_RICH / FASTMCP_PLAIN\n- Allows explicit control for debugging\n- Human can force rich output even when debugging agent runs\n- Takes highest precedence for user control\n\n### NO_COLOR\n- Standard from https://no-color.org/\n- Widely adopted across CLI tools\n- Accessibility consideration for users with visual impairments\n\n### Agent Context Detection\n- MCP_CLIENT: Could be set by any MCP client implementation\n- CLAUDE_CODE: Set by Claude Code CLI\n- CODEX_CLI: Set by OpenAI Codex\n- CURSOR_SESSION: Set by Cursor IDE\n- AIDER_SESSION: Set by Aider tool\n\n### CI Detection\n- These environments parse output programmatically\n- Rich output can break CI log parsing\n- Better to default to plain in automated contexts\n\n### TTY Check\n- Final fallback: if stderr is connected to a terminal, a human is likely watching\n- Uses rich_rust's terminal::is_stderr_terminal()\n\n## Acceptance Criteria\n- [ ] Module compiles and exports all public functions\n- [ ] is_agent_context() correctly detects all listed agent environments\n- [ ] is_ci_environment() correctly detects all listed CI systems\n- [ ] should_enable_rich() follows the documented hierarchy\n- [ ] detection_reason() returns accurate human-readable reasons\n- [ ] Unit tests cover all detection paths\n\n## Testing Considerations\nTests should use environment variable manipulation:\n```rust\n#[test]\nfn test_agent_detection() {\n    std::env::set_var(\"MCP_CLIENT\", \"1\");\n    assert\\!(is_agent_context());\n    std::env::remove_var(\"MCP_CLIENT\");\n}\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:04:34.012659503Z","created_by":"ubuntu","updated_at":"2026-01-20T02:59:45.025067914Z","closed_at":"2026-01-20T02:59:45.025024532Z","close_reason":"Implemented in initial crate creation","source_repo":".","compaction_level":0,"original_size":0,"labels":["detection","foundation","phase-1","rich-rust"],"dependencies":[{"issue_id":"bd-nyw","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:04:34.116410245Z","created_by":"ubuntu"},{"issue_id":"bd-nyw","depends_on_id":"bd-3h3","type":"blocks","created_at":"2026-01-19T21:05:56.476769313Z","created_by":"ubuntu"}]}
{"id":"bd-prq","title":"Budget semantics: integrate budget exhaustion + client timeout hints","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T02:27:56.701900472Z","created_by":"ubuntu","updated_at":"2026-01-25T04:33:25.284776811Z","closed_at":"2026-01-25T04:33:25.284759529Z","close_reason":"Budget exhaustion returns RequestCancelled; error code mapping aligns with spec; checkpoint checks budget","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-ryk","title":"Implement snapshot testing utilities for visual regression","description":"## Purpose and Rationale\n\nCreate utilities for snapshot testing of rich output. This allows detecting unintended visual changes by comparing current output against stored snapshots.\n\n## Background\n\nVisual output can regress in subtle ways that are hard to catch with simple assertions. Snapshot testing stores a \"golden\" reference of expected output and compares future runs against it. When output changes, the test fails and shows the diff.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/testing/snapshots.rs\n\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse crate::testing::TestConsole;\n\n/// Snapshot testing for rich console output\npub struct SnapshotTest {\n    name: String,\n    snapshot_dir: PathBuf,\n    update_snapshots: bool,\n}\n\nimpl SnapshotTest {\n    /// Create a new snapshot test\n    pub fn new(name: &str) -> Self {\n        let snapshot_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n            .join(\"tests\")\n            .join(\"snapshots\");\n        \n        Self {\n            name: name.to_string(),\n            snapshot_dir,\n            update_snapshots: std::env::var(\"UPDATE_SNAPSHOTS\").is_ok(),\n        }\n    }\n    \n    /// Set custom snapshot directory\n    pub fn with_snapshot_dir(mut self, dir: impl AsRef<Path>) -> Self {\n        self.snapshot_dir = dir.as_ref().to_path_buf();\n        self\n    }\n    \n    /// Assert output matches snapshot\n    pub fn assert_snapshot(&self, console: &TestConsole) {\n        let actual = console.output_string();\n        self.assert_snapshot_string(&actual);\n    }\n    \n    /// Assert a string matches snapshot\n    pub fn assert_snapshot_string(&self, actual: &str) {\n        let snapshot_path = self.snapshot_path();\n        \n        if self.update_snapshots {\n            // Update mode: save the new snapshot\n            self.save_snapshot(actual);\n            return;\n        }\n        \n        if !snapshot_path.exists() {\n            panic!(\n                \"Snapshot '{}' does not exist. Run with UPDATE_SNAPSHOTS=1 to create it.\\n\\\n                 Actual output:\\n{}\",\n                self.name, actual\n            );\n        }\n        \n        let expected = fs::read_to_string(&snapshot_path)\n            .expect(\"Failed to read snapshot file\");\n        \n        if actual != expected {\n            // Generate diff\n            let diff = self.generate_diff(&expected, actual);\n            panic!(\n                \"Snapshot '{}' does not match.\\n\\\n                 Run with UPDATE_SNAPSHOTS=1 to update.\\n\\\n                 Diff:\\n{}\",\n                self.name, diff\n            );\n        }\n    }\n    \n    /// Assert raw output (with ANSI) matches snapshot\n    pub fn assert_raw_snapshot(&self, console: &TestConsole) {\n        let actual = console.raw_output().join(\"\\n\");\n        let snapshot_path = self.snapshot_path_raw();\n        \n        if self.update_snapshots {\n            fs::create_dir_all(&self.snapshot_dir).ok();\n            fs::write(&snapshot_path, &actual).expect(\"Failed to write snapshot\");\n            return;\n        }\n        \n        if !snapshot_path.exists() {\n            panic!(\n                \"Raw snapshot '{}' does not exist. Run with UPDATE_SNAPSHOTS=1 to create.\",\n                self.name\n            );\n        }\n        \n        let expected = fs::read_to_string(&snapshot_path).expect(\"Failed to read snapshot\");\n        \n        if actual != expected {\n            panic!(\"Raw snapshot '{}' does not match.\", self.name);\n        }\n    }\n    \n    fn snapshot_path(&self) -> PathBuf {\n        self.snapshot_dir.join(format!(\"{}.txt\", self.name))\n    }\n    \n    fn snapshot_path_raw(&self) -> PathBuf {\n        self.snapshot_dir.join(format!(\"{}.raw.txt\", self.name))\n    }\n    \n    fn save_snapshot(&self, content: &str) {\n        fs::create_dir_all(&self.snapshot_dir).expect(\"Failed to create snapshot dir\");\n        fs::write(self.snapshot_path(), content).expect(\"Failed to write snapshot\");\n        eprintln!(\"Updated snapshot: {}\", self.name);\n    }\n    \n    fn generate_diff(&self, expected: &str, actual: &str) -> String {\n        // Simple line-by-line diff\n        let expected_lines: Vec<&str> = expected.lines().collect();\n        let actual_lines: Vec<&str> = actual.lines().collect();\n        \n        let mut diff = String::new();\n        let max_lines = expected_lines.len().max(actual_lines.len());\n        \n        for i in 0..max_lines {\n            let exp = expected_lines.get(i).unwrap_or(&\"\");\n            let act = actual_lines.get(i).unwrap_or(&\"\");\n            \n            if exp != act {\n                if !exp.is_empty() {\n                    diff.push_str(&format!(\"- {}\\n\", exp));\n                }\n                if !act.is_empty() {\n                    diff.push_str(&format!(\"+ {}\\n\", act));\n                }\n            }\n        }\n        \n        if diff.is_empty() {\n            \"(no differences - possible whitespace issue)\".to_string()\n        } else {\n            diff\n        }\n    }\n}\n\n/// Convenience macro for snapshot tests\n#[macro_export]\nmacro_rules! assert_snapshot {\n    ($name:expr, $console:expr) => {\n        $crate::testing::SnapshotTest::new($name).assert_snapshot(&$console)\n    };\n}\n\n/// Convenience macro for inline snapshot assertion\n#[macro_export]\nmacro_rules! assert_snapshot_matches {\n    ($console:expr, $expected:expr) => {\n        let actual = $console.output_string();\n        pretty_assertions::assert_eq!(actual, $expected);\n    };\n}\n```\n\n### Usage Example\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use fastmcp_console::testing::{TestConsole, SnapshotTest};\n    use fastmcp_console::assert_snapshot;\n    \n    #[test]\n    fn test_startup_banner_snapshot() {\n        let console = TestConsole::new();\n        let banner = StartupBanner::new(\"TestServer\", \"1.0.0\");\n        banner.render(console.console());\n        \n        // Compare against stored snapshot\n        assert_snapshot!(\"startup_banner\", console);\n    }\n    \n    #[test]\n    fn test_error_display_snapshot() {\n        let console = TestConsole::new();\n        let renderer = RichErrorRenderer::new(/* ... */);\n        \n        let error = Error::Timeout(Duration::from_secs(30));\n        renderer.render(&error, console.console());\n        \n        SnapshotTest::new(\"timeout_error\")\n            .assert_snapshot(&console);\n    }\n}\n```\n\n### Workflow\n\n1. First run: Test fails with \"snapshot does not exist\"\n2. Run with `UPDATE_SNAPSHOTS=1 cargo test` to create snapshot\n3. Review generated snapshot in tests/snapshots/\n4. Subsequent runs compare against stored snapshot\n5. If output changes intentionally, run with UPDATE_SNAPSHOTS=1 again\n\n## Implementation Steps\n\n1. Create testing/snapshots.rs\n2. Implement SnapshotTest struct\n3. Implement assert_snapshot() with diff generation\n4. Add UPDATE_SNAPSHOTS environment variable support\n5. Create assert_snapshot! macro\n6. Add raw snapshot support for ANSI preservation\n7. Document snapshot workflow\n8. Add example snapshot tests\n\n## Acceptance Criteria\n\n- [ ] Snapshots are stored in tests/snapshots/\n- [ ] Missing snapshots cause clear failure message\n- [ ] Diff output is readable and helpful\n- [ ] UPDATE_SNAPSHOTS=1 creates/updates snapshots\n- [ ] Raw snapshots preserve ANSI codes\n- [ ] Macro provides convenient usage\n- [ ] Works with parallel test execution\n\n## Testing Strategy\n\n```rust\n#[test]\nfn test_snapshot_creation() {\n    let tc = TestConsole::new();\n    tc.console().print(\"Test output\");\n    \n    // This would normally use a temp dir for testing\n    let snap = SnapshotTest::new(\"test_snapshot\")\n        .with_snapshot_dir(temp_dir());\n    \n    // First run should fail (no snapshot)\n    // With UPDATE_SNAPSHOTS, should create it\n}\n```\n\n## Dependencies\n\n- Requires TestConsole (bd-2gz)\n- Optional: similar or pretty_assertions crate for better diffs","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-19T21:18:42.980380225Z","created_by":"ubuntu","updated_at":"2026-01-21T10:31:51.784910865Z","closed_at":"2026-01-21T10:31:51.784850131Z","close_reason":"Implemented SnapshotTest with assert_snapshot, assert_raw_snapshot, diff generation, UPDATE_SNAPSHOTS mode, and convenience macros. All 13 tests pass. Also fixed pre-existing test failure in client/traffic.rs (escaped brackets in plain output format).","source_repo":".","compaction_level":0,"original_size":0,"labels":["phase-8","rich-rust","snapshots","testing"],"dependencies":[{"issue_id":"bd-ryk","depends_on_id":"bd-2gz","type":"blocks","created_at":"2026-01-19T21:18:51.302532839Z","created_by":"ubuntu"},{"issue_id":"bd-ryk","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:18:43.023025207Z","created_by":"ubuntu"}]}
{"id":"bd-v3s","title":"Spec alignment: track active request regions for cancel/drain","description":"Track active request regions so server can cancel/drain in-flight work: maintain a registry of active request IDs -> region handles, update on start/finish, and use it for cancel/drain semantics (graceful shutdown, targeted cancel). Align with EXISTING_FASTMCP_STRUCTURE.md and asupersync region model.","acceptance_criteria":"Registry: active requests added/removed deterministically; no leaks after completion or panic. Server wiring: cancel/drain enumerates active regions and triggers cancellation without deadlocks. Unit tests for registry lifecycle and concurrent add/remove. Integration tests simulate multiple in-flight requests and verify cancel/drain behavior + correct outcomes. E2E script runs concurrent requests, triggers drain, and logs per-request start/finish/cancel with timings.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T02:27:34.197910185Z","created_by":"ubuntu","updated_at":"2026-01-25T10:30:49.348996419Z","closed_at":"2026-01-25T10:30:49.348978916Z","close_reason":"Implemented active request registry + cancel/drain semantics with tests (concurrent, await_cleanup, e2e logs). Using synthetic RegionId until real per-request region creation exists; follow-up bd-1eu.","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-y14","title":"Implement PromptTableRenderer for prompt registry display","description":"## Purpose and Rationale\n\nCreate a renderer that displays registered prompts in a beautiful format using rich_rust. Prompts are templated text that clients can request with arguments, useful for AI applications.\n\n## Background\n\nMCP prompts are parameterized text templates that clients can request and fill with arguments. They're particularly useful in AI contexts where consistent prompting patterns are needed. Displaying them clearly helps developers understand available prompt templates.\n\n## Technical Specification\n\n### Core Structure\n\n```rust\n// crates/fastmcp-console/src/handlers/prompt_table.rs\n\nuse rich_rust::{Table, Column, Panel, JustifyMethod, Style};\nuse crate::console::FastMcpConsole;\nuse crate::theme::FastMcpTheme;\nuse crate::context::DisplayContext;\nuse fastmcp::prompt::PromptInfo;\n\n/// Renders prompt registry as beautiful tables\npub struct PromptTableRenderer {\n    theme: FastMcpTheme,\n    context: DisplayContext,\n    show_arguments: bool,\n    show_preview: bool,\n    preview_max_lines: usize,\n}\n\nimpl PromptTableRenderer {\n    pub fn new(theme: FastMcpTheme, context: DisplayContext) -> Self {\n        Self {\n            theme,\n            context,\n            show_arguments: true,\n            show_preview: false,\n            preview_max_lines: 3,\n        }\n    }\n    \n    /// Render prompts as a table\n    pub fn render(&self, prompts: &[PromptInfo], console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_plain(prompts, console);\n            return;\n        }\n        \n        if prompts.is_empty() {\n            console.print(\"[dim]No prompts registered[/]\");\n            return;\n        }\n        \n        let mut table = Table::new()\n            .title(format!(\"ðŸ’¬ Registered Prompts ({})\", prompts.len()))\n            .with_column(Column::new(\"Name\").style(self.theme.primary_style()))\n            .with_column(Column::new(\"Description\").max_width(45))\n            .with_column(Column::new(\"Arguments\").justify(JustifyMethod::Center));\n        \n        for prompt in prompts {\n            let name = &prompt.name;\n            let desc = self.truncate(&prompt.description, 45);\n            let args = self.format_arguments(&prompt.arguments);\n            \n            table.add_row_cells([name.as_str(), &desc, &args]);\n        }\n        \n        console.print_renderable(&table);\n    }\n    \n    /// Render a single prompt with full detail\n    pub fn render_detail(&self, prompt: &PromptInfo, console: &FastMcpConsole) {\n        if !self.context.should_use_rich() {\n            self.render_detail_plain(prompt, console);\n            return;\n        }\n        \n        // Prompt name header\n        console.print(&format!(\"\\n[bold magenta]{}[/]\", prompt.name));\n        console.print(&format!(\"[dim]{}[/]\\n\", prompt.description));\n        \n        // Arguments table\n        if !prompt.arguments.is_empty() {\n            let mut arg_table = Table::new()\n                .title(\"Arguments\")\n                .with_column(Column::new(\"Name\").style(self.theme.secondary_style()))\n                .with_column(Column::new(\"Required\").justify(JustifyMethod::Center))\n                .with_column(Column::new(\"Description\"));\n            \n            for arg in &prompt.arguments {\n                let required = if arg.required { \"âœ“\" } else { \"\" };\n                arg_table.add_row_cells([\n                    arg.name.as_str(),\n                    required,\n                    arg.description.as_deref().unwrap_or(\"\"),\n                ]);\n            }\n            \n            console.print_renderable(&arg_table);\n        }\n        \n        // Template preview (if enabled)\n        if self.show_preview {\n            if let Some(template) = &prompt.template {\n                console.print(\"\\n[dim]Template Preview:[/]\");\n                \n                let preview = self.preview_template(template);\n                let panel = Panel::from_text(&preview)\n                    .style(self.theme.dim_border_style());\n                \n                console.print_renderable(&panel);\n            }\n        }\n    }\n    \n    fn format_arguments(&self, args: &[ArgumentInfo]) -> String {\n        if args.is_empty() {\n            \"none\".to_string()\n        } else {\n            let required = args.iter().filter(|a| a.required).count();\n            let optional = args.len() - required;\n            \n            match (required, optional) {\n                (r, 0) => format!(\"{} required\", r),\n                (0, o) => format!(\"{} optional\", o),\n                (r, o) => format!(\"{} req, {} opt\", r, o),\n            }\n        }\n    }\n    \n    fn preview_template(&self, template: &str) -> String {\n        let lines: Vec<&str> = template.lines().take(self.preview_max_lines).collect();\n        let preview = lines.join(\"\\n\");\n        \n        if template.lines().count() > self.preview_max_lines {\n            format!(\"{}\\n[dim]...[/]\", preview)\n        } else {\n            preview\n        }\n    }\n    \n    fn truncate(&self, s: &str, max: usize) -> String {\n        if s.len() <= max {\n            s.to_string()\n        } else {\n            format!(\"{}...\", &s[..max - 3])\n        }\n    }\n    \n    fn render_plain(&self, prompts: &[PromptInfo], console: &FastMcpConsole) {\n        console.print(&format!(\"Registered Prompts ({})\", prompts.len()));\n        for prompt in prompts {\n            console.print(&format!(\"  {} - {}\", prompt.name, prompt.description));\n        }\n    }\n    \n    fn render_detail_plain(&self, prompt: &PromptInfo, console: &FastMcpConsole) {\n        console.print(&format!(\"Prompt: {}\", prompt.name));\n        console.print(&format!(\"Description: {}\", prompt.description));\n        for arg in &prompt.arguments {\n            let req = if arg.required { \"required\" } else { \"optional\" };\n            console.print(&format!(\"  - {} ({})\", arg.name, req));\n        }\n    }\n}\n```\n\n### Visual Example\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ðŸ’¬ Registered Prompts (3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Name              â”‚ Description                             â”‚ Argumentsâ”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ code_review       â”‚ Generate a code review for the given... â”‚ 2 req    â”‚\nâ”‚ summarize         â”‚ Summarize the provided text             â”‚ 1 req, 1 opt â”‚\nâ”‚ translate         â”‚ Translate text to the target language   â”‚ 2 required â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Implementation Steps\n\n1. Create handlers/prompt_table.rs\n2. Implement render() for table view\n3. Implement render_detail() for single prompt\n4. Add argument formatting logic\n5. Add template preview feature\n6. Implement plain-text fallback\n7. Test with various prompt configurations\n\n## Acceptance Criteria\n\n- [ ] Table displays all prompts correctly\n- [ ] Argument counts are accurate\n- [ ] Detail view shows all arguments\n- [ ] Template preview works when enabled\n- [ ] Plain-text fallback is functional\n- [ ] Empty prompt list handled gracefully\n\n## Dependencies\n\n- Requires FastMcpConsole (bd-3js)\n- Requires FastMcpTheme (bd-14i)\n- Requires DisplayContext (bd-nyw)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:15:19.313502474Z","created_by":"ubuntu","updated_at":"2026-01-21T09:21:31.251777810Z","closed_at":"2026-01-21T09:21:31.251726033Z","close_reason":"done","source_repo":".","compaction_level":0,"original_size":0,"labels":["phase-6","prompts","rich-rust","tables"],"dependencies":[{"issue_id":"bd-y14","depends_on_id":"bd-14i","type":"blocks","created_at":"2026-01-19T21:16:02.182541278Z","created_by":"ubuntu"},{"issue_id":"bd-y14","depends_on_id":"bd-39f","type":"parent-child","created_at":"2026-01-19T21:15:19.351300871Z","created_by":"ubuntu"},{"issue_id":"bd-y14","depends_on_id":"bd-3js","type":"blocks","created_at":"2026-01-19T21:16:02.041973005Z","created_by":"ubuntu"},{"issue_id":"bd-y14","depends_on_id":"bd-nyw","type":"blocks","created_at":"2026-01-19T21:16:02.313571161Z","created_by":"ubuntu"}]}
